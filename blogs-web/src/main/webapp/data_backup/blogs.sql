/*
Navicat MySQL Data Transfer

Source Server         : 阿里云服务器数据库
Source Server Version : 50725
Source Host           : 47.102.210.138:3306
Source Database       : blogs

Target Server Type    : MYSQL
Target Server Version : 50725
File Encoding         : 65001

Date: 2019-09-05 10:59:32
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `article_id` int(11) NOT NULL AUTO_INCREMENT,
  `article_user_id` int(11) unsigned DEFAULT NULL,
  `article_title` varchar(255) DEFAULT NULL,
  `article_content` mediumtext,
  `article_view_count` int(11) DEFAULT '0',
  `article_comment_count` int(11) DEFAULT '0',
  `article_like_count` int(11) DEFAULT '0',
  `article_is_comment` int(1) unsigned DEFAULT NULL,
  `article_status` int(1) unsigned DEFAULT '1',
  `article_order` int(11) unsigned DEFAULT NULL,
  `article_update_time` datetime DEFAULT NULL,
  `article_create_time` datetime DEFAULT NULL,
  PRIMARY KEY (`article_id`)
) ENGINE=MyISAM AUTO_INCREMENT=57 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('36', '3', '一起来happy', '<p>该系统采用SSM实现的一个个人博客</p><p><br></p><p>搭建环境为两台阿里云服务器部署了三台tomcat，四个redis分别在两台服务器上（当时跨账号内网互通确实是搞了一会儿<img src=\"http://www.yangdali.cn:8080/plugin/layui/images/face/15.gif\" alt=\"[生病]\">）</p><p><br></p><p>主要涉及的技术为Maven、Spring、SpringMVC、MyBatis、Redis、JSP、dubbo、zookeeper等。</p><p><br></p><p>前端页面是采用Layui框架，样式为扒的别人的前台样式。</p><p><br></p><p>缓存采用redis集群(两主两从)。</p><p><br></p><p>现阶段访问权限仅为一个拦截器进行拦截。</p><p><br></p><p>下一阶段优化包括如下：</p><p><br></p><p>1.权限及登陆控制采用shiro实现</p><p><br></p><p>2.将登陆用户信息完全移交给redis缓存</p><p><br></p><p>3.继续修改页面上的一些bug问题</p>', '18', '2', '1', '1', '1', '1', '2019-05-23 15:56:37', '2019-05-23 15:56:37');
INSERT INTO `article` VALUES ('37', '3', 'DigestUtils调用md5Hex对用一个输入流连续加密返回不同md5码', '<p>记一次开发过程中出现的问题。</p><p><span>关于org.apache.commons.codec.digest.DigestUtils的这个类，对一个输入流连续的进行两次加密，输出的MD5码不同，如果多次连续加密，则除过第一次得到的MD5码都一致。</span></p><p>前一段儿时间在公司写接口的项目，webservice的那种，中途碰到一个问题。具体情况是别的公司调用我们的接口上传一些数据，其中设计到MD5码加密的问题，传过来文件及MD5码，然后我们去校验是否一致（此处有个疑问就是别人可能改文件也可能改MD5码的哇，到现在也没相通为啥要多这一步，，，当然了，这都是扯淡，跟本次问题没啥关系，继续说）。刚开始一切正常，突然有一天一家保险公司的人跟我们反馈MD5码校验一直不通过，问我们是否是用同一个工具去进行MD5码加密的。查过程序没有问题以后，我将报文以及加密后的MD5码要了过来，自己编写了一个测试类测试了一下。（当时回复的也是我们这边儿程序没有问题，请调用方自查系统）</p><p><br></p><p>//从本地c盘读入一个文件流</p><p><span>		</span>FileInputStream fileInputStream = new FileInputStream(new File(\"C:/MyDrivers/123.txt\"));</p><p><span>		</span>//查看是否相同</p><p><span>		</span>System.out.println(\"d41d8cd98f00b204e9800998ecf8427e\".equals(DigestUtils.md5Hex(fileInputStream)));</p><p><br></p><p>发现他发给我的md5确实和文件加密不一致。</p><p>经过一系列测试以后，发现同一个文件流经过多次加密后，第一次与第二次及以后的加密结果不一致，到网上搜了半天，也没发现有相应的解释。</p><p>于是我在空闲时间翻了翻源码，于是在看到下边儿这个方法的时候发现了问题：</p><p>/**</p><p>&nbsp; &nbsp; &nbsp;* Reads through an InputStream and updates the digest for the data</p><p>&nbsp; &nbsp; &nbsp;*</p><p>&nbsp; &nbsp; &nbsp;* @param digest</p><p>&nbsp; &nbsp; &nbsp;*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The MessageDigest to use (e.g. MD5)</p><p>&nbsp; &nbsp; &nbsp;* @param data</p><p>&nbsp; &nbsp; &nbsp;*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Data to digest</p><p>&nbsp; &nbsp; &nbsp;* @return the digest</p><p>&nbsp; &nbsp; &nbsp;* @throws IOException</p><p>&nbsp; &nbsp; &nbsp;*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;On error reading from the stream</p><p>&nbsp; &nbsp; &nbsp;* @since 1.8</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];</p><p>&nbsp; &nbsp; &nbsp; &nbsp; //此处注意</p><p>&nbsp; &nbsp; &nbsp; &nbsp; int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);</p><p>&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; while (read &gt; -1) {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; digest.update(buffer, 0, read);</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);</p><p>&nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return digest;</p><p>&nbsp; &nbsp; }</p><p>看到这里时，我发现了inputStream流调用了read()方法。又生成了一个1024长度的byte数组，并且在读完的时候调用了digest.update方法。对该对象进行了操作。此处，我才发现问题，是在第一次加密的时候，已经将整个输入流读入完成。导致第二次操作的时候再次read()返回了-1，这样导致第二次以后的digest对象都是初始化的对象。原因终于找到。</p><p><br></p><p>事后想想，当时他们肯定是在生成MD5码的时候调用了多次，才会发生初始化MD5码与结果不相同。但是当时也没有看这么细，也就回复了一句我们这边儿没有问题草草结束。最后他们应该是进行了更正，没有提出新的问题。</p>', '15', '0', '0', '1', '1', '1', '2019-05-27 20:27:25', '2019-05-24 13:31:38');
INSERT INTO `article` VALUES ('38', '3', '算法--尾部的零', '<p><b>前言</b></p><p><b>&nbsp; </b>依稀记得大学时期参加的acm,前段时间无聊又想搞点儿好玩儿的，无聊的找了个刷题网站--领扣。准备找个简单的先刷刷成就感，谁知道一不小心，搞了两三个小时没搞出来。最终凭借“别人”的算法思想解决了问题。我就想起了以前看的一篇文章作者的话--“科学的思维指导确实必不可少，‘野路子’的朴素战斗理论不论是效率还是后续的算法演进都经不起考验”。</p><p><b>正文</b></p><p><b>&nbsp; 题目</b></p><p><b>&nbsp; &nbsp;&nbsp;<img src=\"/uploads/2019/5/20190527193633.png\" alt=\"20190527193633.png\"></b></p><p>面对这个问题，我的第一反映是计算出结果，然后将结果每次除以10，记录个数，直到不等于零，然后返回记录结果，很简单就实现了。</p><p>但是将代码提交以后，一个大大的红色的Time Limit Exceeded就甩在了我脸上。哈，一定是哪儿出现了问题，于是经过了简单的思考后，又产生了如下的算法</p><p><b>以5为迭代步数</b></p><p>仔细的思考后，会发现末尾出现的0是5与2相乘的结果，接下来就可以分为5和偶数的倍数分析。</p><p>由于偶数增长的速度远远比5要快，所以后边只进行5倍数的考虑。</p><p>设置一个循环体，判断是多少幂次项，并将结果进行相加。</p><p>综上所述，代码如下：</p><p></p><p>public long trailingZeros(long n) {</p><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; long count = 0;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; long sign = 25;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; for (long temp = 5; temp &lt;= n; temp+=5) {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // for循环内部的temp都是5的倍数，因此首先进行+1操作</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count++;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign = 25;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 判断是不是25、125、625...的倍数，并根据每次sign的变化进行+1操作</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (temp % sign == 0) {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count++;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign *= 5;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return count;</p><p>&nbsp; &nbsp; }</p><p>经过如上思考，发现代码的时间复杂度为O(N)，仍然达不到要求的O(logN)，不粗所料。这种算法仍然达不到要求</p><p><b>科学思想</b></p><p>最后了解到的这个算法真的是感触很深，对平时很多习以为常的公式，道理有了非常直观的认识，因此对自己的冲击很大，推翻了很多以前自己的自以为是，同时也促进了思考的进步。</p><p>1、2、3、4、5、6、7、8、9、10、11、12...</p><p>分析上边的数列可得知，没五个数中会出现一个可以产生0的数字，将这些提出来以后：</p><p>5、10、15、20、25...</p><p>这些数字其实都能满足5*k的数字，是5的倍数。统计一下他们的数量：n1=N/5。比如如果是101，则101之前的这些数字，共101/5=20个数字满足要求。</p><p>将上述数字转化成5*（1、2、3、4、5、6、...）这种形式，发现内部又能满足上边的分析：每五个数字有一个是5的倍数，经过抽取后</p><p>这些数字都是25的倍数，自然也都满足5*k的要求。</p><p>经过上面的分析，后续的操作重复上述步骤即可。</p><p>统计一下第二次中满足条件的数字数量：n2=N/5/5，101/25=(101/5)/5=4。&nbsp;</p><p><span>			</span>因为25、50、75、100、125、...它们都满足相乘后产生至少两个0，在第一次5*k分析中已经统计过一次。对于N=101，是20。因此此处的5*5*k只要统计一次4即可，不需要根据25是5的二次幂统计两次。&nbsp;</p><p><span>			</span>后面的125,250,...等乘积为1000的可以为结果贡献3个0的数字，只要在5*5*k的基础上再统计一次n3=((N/5)/5)/5即可</p><p>将上面思想转化为代码：</p><p>public long trailingZeros(long n) {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; long count = 0;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; long temp=n/5;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; while (temp!=0) {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count+=temp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp/=5;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return count;</p><p>&nbsp; &nbsp; }</p><p>上述算法每次循环均有除以5的操作，也就是每次都会将所要处理的长度缩小至上一次的1/5.所以时间复杂度为O(logN)</p><p><b>小结</b></p><p><b>&nbsp; </b>从最总的代码来看，结果还是比较简单的，但是思考的过程确实很让人抓狂。之所以没有直接得出最优化的结果，写出复杂度为O(logN)的效果，个人觉得原因是因为没有真正理解O(logN)的含义。</p><p>类似于二叉树搜索树，从根节点开始比较，比根节点小，则于左子树比较，比根节点大则于右子树比较，相等或者达到叶子节点后推出。如此循环迭代，每次判断后，下一次可搜索的数据量均为上一次的1/2，如此循环复杂度为O(logN)</p><p><b>理论&amp;实践</b></p><p><span>先分析理论然后落实到实践，还是先动手做，再结合/总结升华出理论，值得推敲。&nbsp;</span></p><p><span>理性思考有助于身体健康，切记切记。与君共勉。</span></p>', '11', '0', '0', '1', '1', '1', '2019-05-29 17:25:57', '2019-05-27 20:27:04');
INSERT INTO `article` VALUES ('39', '3', '有关延时队列的一个使用--公告置顶', '<p><b>前言</b></p><p><b>&nbsp;</b>&nbsp; &nbsp;平时去想做一个什么东西，真的不能只是想想那么简单。确实要实际动手去敲一下，要不然碰见了需要这个技术的时候，到时候怎么死的都不知道。</p><p><b>需求</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>最近做项目的时候，碰到了一个应该是很常见的需求。管理员需要置顶一个公告，设置公告置顶的起始时间以及结束时间，置顶的公告需要展示在各个系统公告栏的最上方。</p><p><b>分析</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>碰到这个需求的时候，因为他的置顶时间是根据天来算的，然后我的分析就如下展开了：</p><p>&nbsp; &nbsp; 方案一：程序定时任务，每天0点的时候去数据库中直接进行update符合置顶起始时间小于当前时间并且结束时间大于当前时间的，将其状态修改为置顶，将结束时间大于当前时间的并且置顶的公告修改为非置顶。</p><p>&nbsp; &nbsp; 这个方案不管实现上和技术上都非常简单，但是存在着一些缺点，首先是数据量如果特别大，在几万或者几十万以上，修改起来数据库的压力可能是稍微有点儿大。其次就是时效性差。</p><p>&nbsp; &nbsp; 方案二：延时消息，当时我想到的是消息队列，因为以前做过那种延时发送短信，将发送短信的任务存放到消息队列中，到时发送，当时选择的是rockedMQ。但是因为现在这是个老系统，不好再去进行生产环境的安装，技术版本的确定等。一系列麻烦的问题。</p><p>&nbsp; &nbsp; 方案三：同样是延时消息，最后选择了JDK自带的延时队列--DelayQueue来进行公告置顶的实现。</p><p><b>解决</b></p><p><b>&nbsp; &nbsp; </b>1）管理员置顶公告，设置公告置顶时间范围，将要置顶的公告以（置顶开始时间为过期时间）及已经置顶的公告（置顶结束的时间为过期时间）推入到DelayQueue中</p><p>&nbsp; &nbsp; 2）启动一个检查公告置顶到期的线程，该线程使用delayQueue的take()方法获取到过期的公告，该方法为阻塞犯法，如果当前没有到期的公告，则该方法会一直等待。直到获取到公告后才会进行下一步操作。</p><p>&nbsp; &nbsp; 3）当take()获取到一个到期公告后，按照公告传入的置顶状态及过期时间修改公告的置顶情况</p><p>&nbsp; &nbsp; 4）在公告的service业务层中，需要初始化DealyQueue队列，防止因服务关闭导致的队列中需要修改的公告丢失，而导致的公告过期后仍然置顶。</p><p><b>具体实现</b></p><p><b>&nbsp; &nbsp; </b>延时队列实现bean：</p><p></p><p>/**</p><p>&nbsp;* 用于处理公告置顶Bean</p><p>&nbsp;*</p><p>&nbsp;* @author：yangli<span>	</span></p><p>&nbsp;* @date:2019年6月4日 上午10:16:06</p><p>&nbsp;* @version 1.0</p><p>&nbsp;*/</p><p>public class NoticeDelayde implements Delayed{</p><p><br></p><p><span>	</span>/**</p><p><span>	</span> * 到期时间，</p><p><span>	</span> */</p><p><span>	</span>private Date markTime;</p><p><span>	</span>/**</p><p><span>	</span> * 公告实体类</p><p><span>	</span> */</p><p><span>	</span>private SmcNoticedeal smcNoticedeal;</p><p><span>	</span></p><p><span>	</span>/**</p><p><span>	</span> * Delayed接口集成了Comparable接口，按照剩余时间进行排序</p><p><span>	</span> * 剩余时间越少的排在队列的头部</p><p><span>	</span> * 实际计算考虑精度为小时</p><p><span>	</span> *&nbsp;</p><p><span>	</span> * @param o</p><p><span>	</span> * @return</p><p><span>	</span> * @version: v1.0.0</p><p><span>	</span> * @author: yangli</p><p><span>	</span> * @date: 2019年6月4日 上午11:26:44&nbsp;</p><p><span>	</span> *</p><p><span>	</span> */</p><p><span>	</span>@Override</p><p><span>	</span>public int compareTo(Delayed o) {</p><p><span>		</span>//getDelay(TimeUnit.HOURS) 新加入的元素到期剩余时间</p><p><span>		</span>//o.getDelay(TimeUnit.HOURS) 当前元素到期剩余时间</p><p><span>		</span>long time = getDelay(TimeUnit.HOURS) - o.getDelay(TimeUnit.HOURS);</p><p><span>		</span>int result = time == 0 ? 0 : (time &lt; 0 ? -1 : 1);</p><p><span>		</span>return result;</p><p><span>	</span>}</p><p><br></p><p><span>	</span>/**</p><p><span>	</span> * 返回到当前日期所剩余的时间</p><p><span>	</span> *&nbsp;</p><p><span>	</span> * @param unit</p><p><span>	</span> * @return</p><p><span>	</span> * @version: v1.0.0</p><p><span>	</span> * @author: yangli</p><p><span>	</span> * @date: 2019年6月4日 上午10:58:55&nbsp;</p><p><span>	</span> *</p><p><span>	</span> */</p><p><span>	</span>@Override</p><p><span>	</span>public long getDelay(TimeUnit unit) {</p><p><span>		</span>long time = unit.convert(this.markTime.getTime() - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</p><p><span>		</span>return time;</p><p><span>	</span>}</p><p><br></p><p><span>	</span></p><p><span>	</span>public NoticeDelayde(Date markTime, SmcNoticedeal smcNoticedeal) {</p><p><span>		</span>super();</p><p><span>		</span>this.markTime = markTime;</p><p><span>		</span>this.smcNoticedeal = smcNoticedeal;</p><p><span>	</span>}</p><p><span>	</span></p><p>}</p><p>公告置顶业务实现类</p><p>@Service</p><p>@Scope(\"singleton\")</p><p>@Lazy(false)</p><p>public class NoticeServiceImpl implements NoticeService{</p><p><span>	</span>private Logger logger = Logger.getLogger(NoticeServiceImpl.class);</p><p><span>	</span></p><p><span>	</span>@Autowired</p><p><span>	</span>private SmcNoticedealService smcNoticedealService;</p><p><span>	</span>//检测弹出到期订单的线程</p><p><span>	</span>private Thread takeOrder;</p><p><span>	</span>//延时队列</p><p><span>	</span>private DelayQueue<noticedelayde> noticeQueue = new DelayQueue<noticedelayde>();</noticedelayde></noticedelayde></p><p><br></p><p><span>	</span>@Override</p><p><span>	</span>public void stickNotice(SmcNoticedeal smcNoticedeal, Date markTime) {</p><p><span>		</span>NoticeDelayde noticeDelayde = new NoticeDelayde(markTime, smcNoticedeal);</p><p><span>		</span>noticeQueue.put(noticeDelayde);</p><p><span>		</span>logger.info(\"公告被推入检查队列，公告id:\" + smcNoticedeal.getId());</p><p><span>	</span>}</p><p><span>	</span></p><p><span>	</span>private class takeOrder implements Runnable{</p><p><span>		</span></p><p><span>		</span>private SmcNoticedealService smcNoticedealService;</p><p><br></p><p><span>		</span>public takeOrder(SmcNoticedealService smcNoticedealService) {</p><p><span>			</span>super();</p><p><span>			</span>this.smcNoticedealService = smcNoticedealService;</p><p><span>		</span>}</p><p><span>		</span>@Override</p><p><span>		</span>public void run() {</p><p><span>			</span>logger.info(\"处理公告置顶线程启动!\");</p><p><span>			</span>while (!Thread.currentThread().isInterrupted()) {</p><p><span>				</span>try {</p><p><span>					</span>//置顶状态</p><p><span>					</span>String stickFlag = \"0\";</p><p><span>					</span>//take是阻塞方法，直到从延迟队列中获取到元素才会往下执行</p><p><span>					</span>NoticeDelayde take = noticeQueue.take();</p><p><span>					</span>//插入队列中的数据肯为以下两种情况</p><p><span>					</span>//1.将要置顶数据（置顶状态为‘1’,且结束时间小于当前时间）</p><p><span>					</span>//2.将要取消置顶数据（置顶状态为‘1’,且结束时间大于当前时间）</p><p><span>					</span>SmcNoticedeal smcNoticedeal = take.getSmcNoticedeal();</p><p><span>					</span>if (smcNoticedeal.getStickEndTime().getTime() &gt; System.currentTimeMillis()) {</p><p><span>						</span>//将置顶状态修改为1，并且将结束时间放入延时队列中</p><p><span>						</span>stickFlag = \"1\";</p><p><span>						</span>NoticeServiceImpl.this.stickNotice(smcNoticedeal, smcNoticedeal.getStickEndTime());</p><p><span>					</span>}</p><p><span>					</span>smcNoticedealService.updateSmcNoticeStickState(take.getSmcNoticedeal().getId(), stickFlag);</p><p><span>				</span>} catch (InterruptedException e) {</p><p><span>					</span>// TODO Auto-generated catch block</p><p><span>					</span>e.printStackTrace();</p><p><span>				</span>}</p><p><span>			</span>}</p><p><span>		</span>}</p><p><span>	</span>}</p><p><span>	</span>/**</p><p><span>	</span> * bean初始化方法，初始化该bean时,开启线程对延时队列中需要置顶的公告进行处理</p><p><span>	</span> *&nbsp;</p><p><span>	</span> * @version: v1.0.0</p><p><span>	</span> * @author: yangli</p><p><span>	</span> * @date: 2019年6月4日 下午1:32:58&nbsp;</p><p><span>	</span> *</p><p><span>	</span> */</p><p><span>	</span>@PostConstruct</p><p><span>	</span>public void init() {</p><p><span>		</span>logger.info(\"公告延时置顶队列线程启动！\");</p><p><span>		</span>takeOrder = new Thread(new takeOrder(smcNoticedealService));</p><p><span>		</span>takeOrder.start();</p><p><span>	</span>}</p><p><span>	</span></p><p><span>	</span>/**</p><p><span>	</span> * bean销毁方法</p><p><span>	</span> *&nbsp;</p><p><span>	</span> * @version: v1.0.0</p><p><span>	</span> * @author: yangli</p><p><span>	</span> * @date: 2019年6月4日 下午1:32:48&nbsp;</p><p><span>	</span> *</p><p><span>	</span> */</p><p><span>	</span>@PreDestroy</p><p><span>	</span>public void close() {</p><p><span>		</span>takeOrder.interrupt();</p><p><span>	</span>}</p><p>}</p><p>里面参杂着一些公告置顶的处理逻辑，如无需要，可以忽略。</p><p>最后在公告操作业务层，同样利用@PostConstruct在spring初始化公告的时候，去将数据库中不符合条件（过期仍然在置顶或者到了置顶时间未置顶的公告）的数据推入DelayQueue中，便于处理公告线程去修改其置顶状态</p><p></p>', '11', '0', '1', '1', '1', '1', '2019-06-06 15:19:29', '2019-06-04 23:42:19');
INSERT INTO `article` VALUES ('40', '3', '人性两面，善恶并行。', '<p><b>前言</b></p><p><b>&nbsp; &nbsp; </b>人性两面，善恶并行。我不苟同一些人的做法，但是却又同情可怜它们的遭遇。</p><p>&nbsp; &nbsp; 真诚的希望每一个人都可以被善待。如果平淡，最好。如果无法平淡，那就安好。</p><p><b>正文</b></p><p><b>&nbsp; &nbsp; </b>一个女孩儿的讲述：</p><p>&nbsp; &nbsp;&nbsp;<span>我有一个舍友，长着一张清纯的脸，眼睛很漂亮。她什么都不缺。她所拥有的都是我们这个年纪最向往又负担不起的。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><span>潘多拉首饰，祖玛珑香水，</span><span>&nbsp;</span><span>Iv&nbsp;</span><span><font face=\"Helvetica\">手袋，</font>&nbsp;</span><span>iphoneXS … …</span></p><p><font face=\"Times New Roman\">&nbsp; &nbsp;&nbsp;</font><span>刚进大学时，我们宿舍六个人每天晚上都要开一个茶话会，分享自己的家庭、高中的趣事、还有惜懂的感情经历。彻夜长谈到凌晨，有说有笑。只有她似乎并没有那么合群，一言不发，甚至有一些不屑。有人说到同专业哪个男生温柔的时候，总是适时地泼冷水：他们其实并没有我们看到的那么好。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><span>渐渐的，她开始不回宿舍，似乎找了一个男朋友。男朋友对她很大方，当下流行的东西，他都会送她。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><span>我们不喜欢她。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><font face=\"Helvetica\">无论是宿舍的聚餐还是大扫除，她从来没有参与过。她也不会去上课，接近考试时像无头苍蝇一样求这个求那个，补我们的笔记。她喜欢占我们的便宜，我们绞尽脑汁做完一份</font><span> pPt 却不得不在她理直气壮的请求下加上她的名字。她不喜欢洗衣服，不喜欢整理，宁愿脏衣服堆得到处都是，甚至随手堆到我们桌上，床上，也不会洗。她有成堆的快递要取，在最忙的时候让我们帮她，而她的朋友圈，显示她正在纸醉金迷；似乎剩下的我们，都得随时准备为她服务。我们觉得，她是自私的。</span></p><p><font face=\"宋体\">&nbsp;</font><span>她从来没有提及过她的家庭，大概是一个被爸妈宠坏，挥金如土的大小姐吧</span>。</p><p><span>&nbsp; &nbsp;&nbsp;</span><span>我是第一个知道她秘密的人。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><span>她家在距离学校很远的省，火车票在寒假并没有那么好买。她说她要留在学校过年。我家就在大学所在的城市，妈妈来接我时就邀请她一起跨年。我和她都是不情愿的。热情的妈妈告诉了她我家的住址，让她有空就来玩。距离除夕夜前两天，我家的门铃声响起，打开门发现是她，多多少少有点意外。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><span>我们吃了一顿家常饭。虽然平时我不待见她，从小的教育让我懂得来者是客，我们睡一张床。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><span>那一晚她说很羡慕我。我也是从那一晚起，才发现的地方，我只是生活在社会这一潭水最。这一潭水的深，不是我能触及的。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><span>所谓的男朋友是一个年近四十的男人，她被包养了。户斤有的一切东西都是他送的。或者说，是用身体换的。她会喝酒，会跳舞，并且可以把一切男生的追求处理得井井有条：不接受也不拒绝。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><span>当我还认为所有感情都是纯粹的，干净的，美好的时期，她已经开始不得不面对社会的现实。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><span>不是每个人的人生都是一帆风顺的，甚至有时候会想，平淡的生活也是一种求之不得的幸福。我才是那个被宠着的小公主。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><span>她并不是不想回家，也不是买不到票，只是她不敢回家。我们不能选择自己的出生，于是上天就为她随机了一个不堪的家庭。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><font face=\"Helvetica\">她家是在一个都没听说过的小城镇，父亲常年好赌。我至今都不敢相信二十一世纪了还有这样的父亲：高中时委婉地要求她辍学，女孩子读书没用，趁年轻赶紧相识几个金主。母亲也经常在她耳边煽风点火，让她做</font><span>“女孩该做的事”。她父亲欠下的债对于我们家，父母亲有不错的工作的情况下，也让人慎目结舌。而她母亲没读过书，甚至连字都不认识，只能靠做一些手工来补贴家用。但跟债务比起来，就像把一粒一粒小石头丢进海里。她们家重男轻女。她的妈妈经常说生弟弟相当不容易，户斤以要照顾好弟弟。于是她弟弟的生活费和学费也落到了她头上。而讽刺的是，这些对于她来说连想都不敢想的数目，金主只是手一挥就解决了。于是她学会了察言观色，她学会了妖艳妩媚的打扮，她学会了如何讨金主的欢心，她开始承受我们这个年龄不该承受的事。她说，她的一生大概也只能这样啦，永远躲在黑暗的角落里看着我们面对阳光。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><font face=\"Helvetica\">我们的大学不是名校，不是</font><span> 985 211 ，但每个学生都看上去朝气蓬勃的。我曾经以为女生都会是爸爸妈妈的天使被捧在手上，等待自己的白马王子出现。后来发现，生活永远比我想象得复杂。她努力过，家教、售货员、甚至好多男生都不敢挑战的快递工作，都在高中时做过。有几次因为营养不良和过劳晕倒在大街上。这些流汗流泪的努力，最后还是不如金主的一句话。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><span>我看不起做情妇的，并且曾经也在键盘上敲下恶言相向的话，咒骂。直到现在我仍旧觉得这是一件可耻的事情，并且不能理解。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><span>我又觉得她是可怜的。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><font face=\"Helvetica\">就像</font><span> </span><font face=\"Helvetica\">《</font><span> </span><font face=\"Helvetica\">告白</font><span> </span><font face=\"Helvetica\">》</font><span> </span><font face=\"Helvetica\">的一句影评，人性两面，善恶并行。我不苟同她的做法，但是同情可怜她的遭遇。</font></p><p><font face=\"Helvetica\">&nbsp; &nbsp;&nbsp;</font><span>在她脱身前，我会为她保守秘密。</span></p><p><span>&nbsp; &nbsp;&nbsp;</span><span>真诚的希望每一个女孩都可以被善待，如果平淡，最好。如果无法平淡，那就安好。</span></p><p class=\"pre\"><span><font face=\"Helvetica\">&nbsp; &nbsp; 我没有经历过，所以没有资格去评价她。但是真的希望她以后可以好好的。</font></span></p>', '9', '0', '0', '1', '1', '1', '2019-06-17 21:04:07', '2019-06-10 12:36:22');
INSERT INTO `article` VALUES ('41', '3', 'ArrayList与LinkedList', '<p><b>前言</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>说起集合，我不得不顺便提一句数据结构，上大学时对于这个概念是非常模糊的，看了一些资料之后，对其才有了敬畏之心。</p><p>&nbsp; &nbsp; 数据结构是什么？数据结构是指逻辑意义上的数据组织方式及其相应的处理方式。</p><p>-------精致的分割线------</p><p>&nbsp; &nbsp; 说起这两个集合，可能是平时用的比较多的。面试的时候也是逃不了的一个问题。最近看了一些书，趁着脑袋还清楚，来总结一下子。从自己的看法（其实大家都是这样的）来说一下这两个集合的一些东西。</p><p><b>List集合</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>List集合石线性数据结构的主要体现，集合元素通常都回存在明确的上一个元素和下一个元素，也存在第一个和最后一个元素。List集合遍历的结果是稳定的，并且其可以存储重复的元素，且集合有序。通常我们在项目中，所用到的元素就是ArrayList与LinkedList。可能ArrayList用的更多一些。</p><p><b>ArrayList</b></p><p>&nbsp; &nbsp; ArrayList是容量可以改变的非线程安全的结合。内部采用了数组进行实现，当集合存满以后，再次存储就会触发扩容，在JDK7以前，ArrayList扩容为原来长度的1.5倍+1的长度，在JDK7以后，其扩容为原来长度+原来长度&gt;&gt;1的大小。之后使用了位运算，效率更高。</p><p>&nbsp; &nbsp; 初始大小：在ArrayList的源码中，我们可以看到如下的一个静态常量</p><p>&nbsp; &nbsp; /**</p><p>&nbsp; &nbsp; &nbsp;* Default initial capacity.</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; private static final int DEFAULT_CAPACITY = 10;</p><p>&nbsp; &nbsp; 当我们去使用无参构造去创建一个ArrayList的时候，他的默认大小为10，并且在第一次调用该集合的add()方法的时候给集合分配10的容量，后续的每次扩容，都会调用Array.copyOf（）方，创建一个新的数组（长度为上述所说）再进行复制。这里就涉及到一个集合初始化指定大小的一个优化代码的地方。假如利用无参构造初始化了一个ArrayList，需要将1000个元素放入该集合中，则需要被动扩容13次才能完成存储。反之如果初始化时，指定了该集合的大小new ArrayList<t>(1000)，那么在初始化该对象时，就会直接分配1000个存储空间，<b>从而避免被动扩容和数组赋值的额外开销。</b>最后，一个假设，如果这个集合所需要存储的量非常大，如果没有指定初始化长度，则对性能是一个非常大的损耗，甚至导致OOM风险</t></p><p>&nbsp; &nbsp; 由于其底层是素组实现，因此在添加元素的时候，不仅仅要考虑到集合的容量，在容量不够时进行扩容，而且不在最后一位处添加/删除元素时，还要考虑到其之后元素的位置移动问题。最糟糕的是在ArrayList集合的首部进行添加/删除元素，这样就会移动整个数组，带来了比较大的性能消耗。</p><p>&nbsp; &nbsp;同样的，由于其是数组，因而在随机访问的速度上，由于可以直接通过素组的下标去精确获取元素的值，因而该集合在这方面的效率很高。</p><p><b>LinkedList</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>LinkedList的本质是一个双向链表，以前一直不明白什么是链表，单纯的就知道是链表的集合，每个元素存储着前一个和后一个元素的位置，以及自己本身的值。直到看到了LinkedList的源码之后，我才算是明白了什么是链表。</p><p>&nbsp; &nbsp; private static class Node<e> {</e></p><p>&nbsp; &nbsp; &nbsp; &nbsp; E item;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Node<e> next;</e></p><p>&nbsp; &nbsp; &nbsp; &nbsp; Node<e> prev;</e></p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; Node(Node<e> prev, E element, Node<e> next) {</e></e></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.item = element;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.next = next;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.prev = prev;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; }</p><p><b>&nbsp; &nbsp;&nbsp;</b>上述代码就是LinkedList中的一个元素，item存储的就是该元素所存储的对象，prev及next所存储的就是上一个/下一个元素的位置。</p><p>&nbsp; &nbsp; 因为LinkedList是采用链表结构，因此在随机访问的速度上，该集合的效率远远小于ArrayList(利用数组下标去直接获取)。在源码中，我们可以发现</p><p>&nbsp; &nbsp; Node<e> node(int index) {</e></p><p>&nbsp; &nbsp; &nbsp; &nbsp; // assert isElementIndex(index);</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; if (index &lt; (size &gt;&gt; 1)) {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node<e> x = first;</e></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; index; i++)</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = x.next;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return x;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; } else {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node<e> x = last;</e></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = size - 1; i &gt; index; i--)</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = x.prev;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return x;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; 当长度小于该链表长度的一半时，则从头开始去便利该链表，直到获取到所需要的元素。在效率对比方面，十万条的数据，两个集合在随机提取元素的效率存在着百倍之差。</p><p>&nbsp; &nbsp; 在存储和删除元素方面，LinkedList仅仅只需要移动每个元素存储的上一个及下一个元素的位置即可，不必考虑其他的因素，因而在增加和删除元素方面，LinkedList更胜一筹。</p><p>&nbsp; &nbsp; 由于LinkedList的链表的特性，不需要在内存中分配连续的空间去存储，因而其内存利用率较高。</p><p><b>总结</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>总结的话估计都被人说烂了，也就是在随机获取时用ArrayList,而在频繁增加和删除的场景使用LinkedList。</p><div><br></div>', '12', '2', '0', '1', '1', '1', '2019-06-12 19:24:34', '2019-06-12 19:20:33');
INSERT INTO `article` VALUES ('42', '3', '一个ArrayList中元素排序的问题', '<p><b>前言</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>这个问题可能有点儿low了，但是想起了很久很久以前的一个面试时，对于这个问题我真的是不会呀。</p><p>&nbsp; &nbsp; 我有一个Student的实体类，有name及age两个属性，采用ArrayList去进行存储，如何根据年龄大小进行排序。</p><p>&nbsp; &nbsp; 直到我回去百度了一下子，才发现，当时的自己是真的啥也不会呀。</p><p><b>元素比较之Comparable和Comparator</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>Java中两个对象的比较方法通常用在元素排序中，常用的两个接口是Comparable与Comparator，前者是自己和自己比较，可以看作是自营的比较其，后者则是第三方的比较器，可以看作是平台性质的比较器。</p><p>&nbsp; &nbsp; 以上面的那个问题来说，实现方式有两种。</p><p>&nbsp; &nbsp; 方法一：student类实现Comparable接口，并且实现该接口的compareTo（）方法，判断当前元素与传入元素的age大小。</p><p>&nbsp; &nbsp; 方法二：采用Comparator的compare方法，利用Arrays.sort方法中作为比比较器参数进行排序。在JDK8中，该接口为@FunctionalInterface的，也就是可以利用Lambda表达式去编写，更加简便。</p><p>&nbsp; &nbsp; 不管是Comparable还是Comparator，小于的情况返回-1，等于返回0，大于返回1.</p><p><b>TimSort</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>上述所说的sort()就用到了TimSort算法，是归并排序与插入排序优化后的排序算法。</p><p>&nbsp; &nbsp; 首先回顾一下归并排序的原理。长度为1的数组是排序好的，有n个元素的集合可以看成是n个长度为1的有序子集合；对有序子集合进行两两归并，并保证结果子集合有序，最后得到n/2个长度为2的有序子集合；重复上一步骤知道所有元素归并成一个长度为n的有序集合。在此排序过程中，主要工作都在归并处理中，如何使归并过程更快，或者如何减少归并次数，成为优化归并排序的重点。</p><p>&nbsp; &nbsp; TimSort算法避免了归并排序和插入排序的缺点，相对传统归并排序，减少了归并次数，相对插入排序，引入了二分排序的概念，提升了排序效率。TimSort算法相对于已经部分排序的数组，时间复杂度最优可达O(n);对于随机的数组，时间复杂度为O(nlogN)，平均时间复杂度为O(nlogN)。因此在JDK7中使用TimSort算法取代了原来的归并排序。</p>', '11', '0', '3', '1', '1', '1', '2019-06-12 20:06:18', '2019-06-12 20:06:18');
INSERT INTO `article` VALUES ('43', '3', '有关http的一些感慨', '<p><b>前言</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>国际惯例，上来先来讲两句废话。上学时，对于http的了解仅仅限于考试需要考，我们平时输入网址的时候需要带上http。仅此而已。。。以前面试的时候也碰到了人问，当时也是笑着跟面试官说，大学没有好，结果被人家硬生生的怼了回来---对于HTTP协议的了解还是很重要的（开心汽车面试官）</p><p><b>场景</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>其实，在开发过程中，我也不断的发现了问题。安全测试的一些拦截用户请求，修改的就是用户请求数据中的一些参数，产生的一些不可预期的结果，最典型的就是SQL注入与XSS注入，这两个问题在我们这个老系统上，我已经改了N多遍了。不仅仅是安全问题，在一些对接系统上也有体现，发送请求请求网关确认身份信息等等，利用httpclient发送，都得去设定http的请求行，请求头部，请求数据等等一系列的信息。</p><p><b>HTTP概述（用自己的话表述）</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>超文本传输协议，为TCP/IP协议簇中应用层上的一员，由请求信息及响应信息构成，是一个无状态的协议（发送一次后，则断开连接，不记录连接状态等一些信息），该协议承载与TCP协议之上。默认端口号为80（当端口号为80时可以省略不写）。http协议常用于网页之上，当然了，只要遵守这个协议的规定，都是可以采用这个协议去进行信息传输的。</p><p><b>HTTP构成</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>http协议包含请求信息及响应信息。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 请求信息包含：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 请求行---请求类型(get,post)，请求资源，版本号</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 请求头部----host，请求地址，User-Agent，用户的一些信息</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 空行---即使没有请求数据，这个空行也必须存在（原因还未可知）</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 请求数据---表单提交的参数等等（一般拦截请求后修改信息则是修改此处的参数，达到sql注入等侵入操作）</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 响应信息包含：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 状态行---版本号，状态码（200、404等），消息状态</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 消息报头----Date生成时间，Content-Type响应类型，编码</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 空行---跟请求信息一样，一定存在的空行</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 响应正文---后台返回给页面的数据，Json数据，Xml报文等等。</p><p>&nbsp; &nbsp; http的状态码及表示意义：1xx(正在处理)、2xx(成功-被接受)、3xx(重定向-需要进一步处理)、4xx(错误-客户端请求错误)、5xx(错误-服务端错误)</p><p>&nbsp; &nbsp; 我们常见的就是：200(请求成功)、400(语法错误，不能解析)、403(收到请求，但拒绝服务)、404(访问资源不存在)、500(服务端出现异常)、503(过会儿处理)</p><p><b>常见GET与POST</b></p><p>&nbsp; &nbsp; 常见的就是上述两种请求方式，不同大致就是那么几点，get请求把参数放到了请求行，因而url地址栏可见，因为浏览器限制的原因，长度有最大值（理论上和post一样，都为无限长度），而post把请求信息放到了请求数据中去，因而没有长度限制。get请求参数只能是ASCII码，而post不做限制。get请求会被缓存，而post请求不会。get请求适合作为查询的请求，post适合作为增删改请求的类型等等。</p><p>&nbsp; &nbsp; 然而我也是前不久才知道，get请求很多浏览器发送一个包，post请求发送两个请求包。(现在还处于一脸懵逼状态，有空查询后在评论做补充)</p><p><b>总结</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>正如上次那个面试官所说的一样，了解http还是很重要的，只有了解过后，才能面对问题能够迅速的解决。</p><div><br></div>', '10', '1', '0', '1', '1', '1', '2019-06-24 13:13:39', '2019-06-17 21:03:38');
INSERT INTO `article` VALUES ('44', '3', '【转】假笨说-又抓了一个导致频繁GC的鬼--数组动态扩容', '<h2 style=\"text-align: justify;\">概述</h2><p style=\"text-align: justify;\">本周有个同事过来咨询一个比较诡异的gc问题，大概现象是，系统一直在做cms gc，但是老生代一直不降下去，但是执行一次<code>jmap -histo:live</code>之后，也就是主动触发一次full gc之后，通过<code>jstat -gcutil</code>来看老生代一下就降下去了，初看下理论上不太可能，因为full gc也会对old做回收，于是我要同事针对他们的场景写了一个简单的demo出来，然后果然还真能重现，不过他的demo设置的Heap有32G，于是我通过慢慢调整，最终在很小的内存下也能重现出来</p><h2 style=\"text-align: justify;\">Demo</h2><p style=\"text-align: justify;\">测试代码如下：</p><p style=\"text-align: justify;\"><img src=\"/uploads/2019/6/640(1).png\" alt=\"640.png\"><br></p><p style=\"text-align: justify;\">正如我上面注释里写的JVM参数，控制新生代200M，老生代300M，老生代使用率达到90%的时候触发CMS GC，大家可以跑跑看，这种情况下会发现不断做CMS GC，但是老生代就是不降下去，但是只要你主动触发一次Full GC，老生代立马就会回收。</p><p style=\"text-align: justify;\">当allocateMemory方法执行完之后，期待的结果是gc之后List及里面的byte数组都应该被回收掉，可是事实并不是这样的</p><h2 style=\"text-align: justify;\">初步定位</h2><p style=\"text-align: justify;\">这段代码非常简单，我翻来覆去地看着这段代码，视图想改变点什么，能让问题出现峰回路转，我不断地控制for循环的次数和每次分配的内存大小，最终我将目标转移到那个ArrayList上，List里有个数组，在add过程中如果发现数组不够了，于是会进行扩容，那扩容就是创建新的数组，将老的对象放到新数组里，那我试想要是不做扩容会不会有问题？于是我开始调整ArrayList的初始化大小，当我调到一定大小，保证在add过程中不会做扩容，问题真出现了反转，居然能正常回收了，比如上面的demo，将数组长度设置为len，那结果就完全不一样了，老生代很快就被回收了<br>那目标能锁定到数组扩容了</p><h2 style=\"text-align: justify;\">数组扩容</h2><p style=\"text-align: justify;\">ArrayList里的数组扩容，使用的是<code>System.arrayCopy</code>调用，这是一个native方法，在java层面创建一个新的长度的数组，然后将老数组和新数组都传进去，在native里将老数组里的元素指针拷贝到新数组里，其实做的是浅拷贝，反复看native这块实现，也基本解释不通那个现象，一度怀疑我对GC的理解了，是不是有哪些细节没有注意到。<br>经过我内存dump分析，发现上面Demo里的List对象确实被回收了，但是List里的数组没有被回收，这个数组里的byte数组都没有被回收</p><h2 style=\"text-align: justify;\">原来是这个鬼</h2><p style=\"text-align: justify;\">带着百思不得其解的疑惑和我们组同事讨论，看看还有没有其他可能的没考虑到疑惑点，开始也都觉得疑惑，后来传胜突然想到会不会是存在跨代引用的问题，于是回过来仔细再想想每个步骤，好像还真有可能，因为传给<code>System.arrayCopy</code>的新数组是在java层面构建传进来的，在新生代分配的可能性最大，这样再加上拷贝仅仅是浅拷贝，那么老生代里的byte数组因为存在新生代里新书组的引用，那仅仅做CMS GC就不可能回收这些老生代的对象了，因为CMS GC的一个gc root就是新生代里的对象</p><h2 style=\"text-align: justify;\">那何解</h2><p style=\"text-align: justify;\">至此终于抓出了那个鬼，于是想应对策略，既然这样，只要保证在cms gc回收old之前做一次ygc就能保证新生代里的那个新数组被回收而没有指向老生代那些byte数组，那么这些数组就能正常被cms gc回收了，所以加上<code>-XX:+CMSScavengeBeforeRemark</code>即可解此问题</p>', '19', '1', '1', '1', '1', '1', '2019-06-17 21:14:48', '2019-06-17 21:14:18');
INSERT INTO `article` VALUES ('45', '3', '有关JVM调优的初步学习（一）', '<p><b>前言</b></p><p>&nbsp; &nbsp; 先把标题占上，刚好最近阿里云社区请了一个小米的开发来讲这个知识点，虽然说是看了一遍，但是确实是云里雾里的，回头等复习的时候这个就作为笔记写了。</p>', '7', '0', '0', '1', '1', '1', '2019-06-17 21:32:12', '2019-06-17 21:20:36');
INSERT INTO `article` VALUES ('46', '3', '回头看看，jvm的类加载过程', '<p><b>前言</b></p><p><b>&nbsp; &nbsp; </b>写了这么长时间的代码，平时看到了一些类的初始化，还是有很多的不确定，还得翻书去查查加载顺序以及初始化过程。看看到用的时候是否已经加载完毕或者初始化完成。今天琢磨了一下，突然发现脑子一片空白。想到最后还是觉得看看书，然后敲出来比较好。</p><p><b>概述</b></p><p><b>&nbsp; &nbsp; </b>冯·诺依曼定义的计算机模型中，任何程序都要加载到内存中，才可以与cpu进行交互。字节码.class文件同样需要加载到内存中，才可以进行实例化。ClassLoader的任务就是提前加载.class文件到内存中。在加载类的时候，使用的是Parents Delegation Model，翻译过来就是我们经常所听到的双亲委派模型，然而《码出高效》中指出，这个翻译为‘溯源委派加载模型’更加贴切。然而我英语烂的不行，对于这方面，大佬说啥我也只能暂时记下来了。</p><p>&nbsp; &nbsp; Java的类加载器是一个运行时核心基础设施模块，主要是在启动之初进行类的Load、Link和Init，即加载、链接、初始化。</p><p>&nbsp; &nbsp; 第一步，Load阶段读取类文件产生的二进制文件流，并转化为特定的数据结构，初步校验一些数值，然后创建对应类的java.lang.Class实例</p><p>&nbsp; &nbsp; 第二步，Link阶段包括验证、准备、解析三个步骤。验证时更详细的校验，比如final是否合规、类型是否正确、静态变量是否合理等；准备阶段是为静态变量分配内存，并设定默认值，解析类和方法确保类与类之间的相互引用正确性，完成内存结构布局。</p><p>&nbsp; &nbsp; 第三部，Init阶段执行类构造器&lt;clinit&gt;方法，如果赋值运算是通过其他类的静态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值。</p><p><img src=\"/uploads/2019/6/微信截图_20190619203059.png\" alt=\"微信截图_20190619203059.png\"><br></p><p><b>扩展</b></p><p><b>&nbsp; &nbsp; </b>new与newInstance的区别。new是强类型校验，可以调用任何构造方法，在使用new操作的时候，这个类可以没有被加载过。而Class类下的newInstance是弱类型，只能调用无参构造方法，如果没有默认构造方法，就抛出异常；如果此构造方法没有权限访问，同样的抛出异常。java通过类加载器把类的实现与类的定义进行解耦，所以是实现面向接口编程、依赖倒置的必然选择。</p><p>&nbsp; &nbsp; -Xbootclasspath/a:/..... 该参数可以增加Bootstrap的类加载路径，可以定义额外的类加载路径用于加载自定义类。不过不建议修改或删除原有的加载路径</p><p>&nbsp; &nbsp; 有关Jar包冲突：-XX:+TraceClassLoading参数，此参数在解决类冲突时非常实用，毕竟不同的jvm环境对于加载类的顺序并非是一致的。</p><p><br></p>', '8', '0', '0', '1', '1', '1', '2019-06-19 20:56:51', '2019-06-19 20:56:51');
INSERT INTO `article` VALUES ('47', '3', '有关BufferReader的一个小问题', '<p><b>问题</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>接收一个xml（大报文可能会达到500M）报文，在报文最后会坠一个字符串，以‘|’符号进行分割，如何获取到这个字符串</p><p><b>思路</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>刚开始想这个问题的时候，就是想到了拿流去将报文内容去加载到内存中，然后根据特定字符去截取，然后发现了，报文太大的时候，光光去获取到这个报文的字符串就容易把内存搞崩。然后就想到了可以一行一行去读取，刚开始没啥问题，但是写完了以后去检查了一下生产环境的报文，发现有的人传xml报文的时候竟然是一行来处理的，这就很过分了，最后看了一下BufferedReader的根据行去读取的时候的代码</p><p>/**</p><p>&nbsp; &nbsp; &nbsp;* Reads a line of text.&nbsp; A line is considered to be terminated by any one</p><p>&nbsp; &nbsp; &nbsp;* of a line feed (\'\\n\'), a carriage return (\'\\r\'), or a carriage return</p><p>&nbsp; &nbsp; &nbsp;* followed immediately by a linefeed.</p><p>&nbsp; &nbsp; &nbsp;*</p><p>&nbsp; &nbsp; &nbsp;* @param&nbsp; &nbsp; &nbsp; ignoreLF&nbsp; If true, the next \'\\n\' will be skipped</p><p>&nbsp; &nbsp; &nbsp;*</p><p>&nbsp; &nbsp; &nbsp;* @return&nbsp; &nbsp; &nbsp;A String containing the contents of the line, not including</p><p>&nbsp; &nbsp; &nbsp;*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;any line-termination characters, or null if the end of the</p><p>&nbsp; &nbsp; &nbsp;*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stream has been reached</p><p>&nbsp; &nbsp; &nbsp;*&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* @see&nbsp; &nbsp; &nbsp; &nbsp; java.io.LineNumberReader#readLine()</p><p>&nbsp; &nbsp; &nbsp;*</p><p>&nbsp; &nbsp; &nbsp;* @exception&nbsp; IOException&nbsp; If an I/O error occurs</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; String readLine(boolean ignoreLF) throws IOException {</p><p>StringBuffer s = null;</p><p>int startChar;</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; synchronized (lock) {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ensureOpen();</p><p>&nbsp; &nbsp; boolean omitLF = ignoreLF || skipLF;</p><p><br></p><p>bufferLoop:</p><p>&nbsp; &nbsp; for (;;) {</p><p><br></p><p>if (nextChar &gt;= nChars)</p><p>&nbsp; &nbsp; fill();</p><p>if (nextChar &gt;= nChars) { /* EOF */</p><p>&nbsp; &nbsp; if (s != null &amp;&amp; s.length() &gt; 0)</p><p>return s.toString();</p><p>&nbsp; &nbsp; else</p><p>return null;</p><p>}</p><p>boolean eol = false;</p><p>char c = 0;</p><p>int i;</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Skip a leftover \'\\n\', if necessary */</p><p>if (omitLF &amp;&amp; (cb[nextChar] == \'\\n\'))&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextChar++;</p><p>skipLF = false;</p><p>omitLF = false;</p><p><br></p><p>&nbsp; &nbsp; charLoop:</p><p>for (i = nextChar; i &lt; nChars; i++) {</p><p>&nbsp; &nbsp; c = cb[i];</p><p>&nbsp; &nbsp; if ((c == \'\\n\') || (c == \'\\r\')) {</p><p>eol = true;</p><p>break charLoop;</p><p>&nbsp; &nbsp; }</p><p>}</p><p><br></p><p>startChar = nextChar;</p><p>nextChar = i;</p><p><br></p><p>if (eol) {</p><p>&nbsp; &nbsp; String str;</p><p>&nbsp; &nbsp; if (s == null) {</p><p>str = new String(cb, startChar, i - startChar);</p><p>&nbsp; &nbsp; } else {</p><p>s.append(cb, startChar, i - startChar);</p><p>str = s.toString();</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; nextChar++;</p><p>&nbsp; &nbsp; if (c == \'\\r\') {</p><p>skipLF = true;</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; return str;</p><p>}</p><p></p><p>if (s == null)&nbsp;</p><p>&nbsp; &nbsp; s = new StringBuffer(defaultExpectedLineLength);</p><p>s.append(cb, startChar, i - startChar);</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; }</p><p>这块儿是根据\\n和\\r去确定读取行的。然后我就觉得，xml特有的尖括号也能成为阶段的标识符哇。然后我就稍做了修改：</p><p>/**</p><p><span>	</span> * 根据解析需求，判断是否为\'&gt;\',如果为\'&gt;\',则取出到前一个\'&gt;\'</p><p><span>	</span> *&nbsp;</p><p><span>	</span> * @param ignoreLF</p><p><span>	</span> * @return</p><p><span>	</span> * @throws IOException</p><p><span>	</span> * @version: v1.0.0</p><p><span>	</span> * @author: yangli</p><p><span>	</span> * @date: 2018年11月9日 下午1:38:16</p><p><span>	</span> *</p><p><span>	</span> */</p><p><span>	</span>@SuppressWarnings(\"unused\")</p><p><span>	</span>String readLine(boolean ignoreLF) throws IOException {</p><p><span>		</span>StringBuffer s = null;</p><p><span>		</span>int startChar;</p><p><br></p><p><span>		</span>synchronized (lock) {</p><p><span>			</span>ensureOpen();</p><p><span>			</span>boolean omitLF = ignoreLF || skipLF;</p><p><br></p><p><span>			</span>bufferLoop: for (;;) {</p><p><br></p><p><span>				</span>if (nextChar &gt;= nChars)</p><p><span>					</span>fill();</p><p><span>				</span>if (nextChar &gt;= nChars) { /* EOF */</p><p><span>					</span>if (s != null &amp;&amp; s.length() &gt; 0)</p><p><span>						</span>return s.toString();</p><p><span>					</span>else</p><p><span>						</span>return null;</p><p><span>				</span>}</p><p><span>				</span>boolean eol = false;</p><p><span>				</span>char c = 0;</p><p><span>				</span>int i;</p><p><br></p><p><span>				</span>/* Skip a leftover \'\\n\', if necessary */</p><p><span>				</span>if (omitLF &amp;&amp; (cb[nextChar] == \'&gt;\'))</p><p><span>					</span>nextChar++;</p><p><span>				</span>skipLF = false;</p><p><span>				</span>omitLF = false;</p><p><br></p><p><span>				</span>charLoop: for (i = nextChar; i &lt; nChars; i++) {</p><p><span>					</span>c = cb[i];</p><p><span>					</span>if ((c == \'&gt;\') || (c == \'*\')) {</p><p><span>						</span>eol = true;</p><p><span>						</span>break charLoop;</p><p><span>					</span>}</p><p><span>				</span>}</p><p><br></p><p><span>				</span>startChar = nextChar;</p><p><span>				</span>nextChar = i;</p><p><br></p><p><span>				</span>if (eol) {</p><p><span>					</span>String str;</p><p><span>					</span>if (s == null) {</p><p><span>						</span>str = new String(cb, startChar, i - startChar);</p><p><span>					</span>} else {</p><p><span>						</span>s.append(cb, startChar, i - startChar);</p><p><span>						</span>str = s.toString();</p><p><span>					</span>}</p><p><span>					</span>nextChar++;</p><p><span>					</span>if (c == \'*\') {</p><p><span>						</span>skipLF = true;</p><p><span>					</span>}</p><p><span>					</span>return str;</p><p><span>				</span>}</p><p><br></p><p><span>				</span>if (s == null)</p><p><span>					</span>s = new StringBuffer(defaultExpectedLineLength);</p><p><span>				</span>s.append(cb, startChar, i - startChar);</p><p><span>			</span>}</p><p><span>		</span>}</p><p><span>	</span>}</p><p>将原方法中的换行符修改为了尖括号，经测试后，确实好使，于是决定采用这种方法去截取加密串</p><p><br></p>', '7', '0', '0', '1', '1', '1', '2019-06-24 13:13:15', '2019-06-21 15:08:10');
INSERT INTO `article` VALUES ('48', '3', 'redis的内存溢出', '<p><b>前言</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>今天给监管系统刷缓存时，系统报错了，提示信息是redis刷行政区划缓存时，内存溢出了（OOM）,对，是redis的内存溢出了。随后就借助百度，重启了服务之后，解决了问题（不晓得是不是根治了，过后启动服务还得试试）</p><p><b>问题</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>redis.clients.jedis.exceptions.JedisDataException: OOM command not allowed when used memory &gt; \'maxmemory\'.</p><p>&nbsp; &nbsp; 异常信息如上，百度了一下，就出来了一大堆解决方案，但是千篇一律的说的都是redis的maxmemory最大内存设置的笑了，又或者将redis内存满后的淘汰策略<span style=\"text-align: justify;\">maxmemory-policy进行修改。</span></p><p><span style=\"text-align: justify;\">&nbsp; &nbsp; 首先，redis内存设置的是10G(大于了系统内存8G),如果说这样设置的结果，跟不限制内存大小是一至的（maxmemory），那么我都没想出来问题到底出在了哪儿。并且行政区划缓存刷进去以后，是不允许其过期进行删除的。因此修改淘汰策略也是行不通的。</span></p><p style=\"text-align: justify;\"><b>解决（不知是否已从根源上解决完成）</b></p><p style=\"text-align: justify;\"><b>&nbsp; &nbsp;&nbsp;</b>首先，我将配置文件中的maxmemory的大小改成了3G，小于了系统内存以后，再次重启redis（删除了持久在硬盘中的aof与rdb文件），并且刷入行政区划，结果仍然报错。再次重启以后，利用了redis-cli的info memory在刷入行政区划的时候查看了内存的分配，发现集群中的每个节点刷入200M左右的行政区划后，就会抛出这样的问题。前思后想，琢磨着不会跟系统内存本身有问题吧。本身内存太小，导致服务器上一瞬间承载不了这么多的数据，然后挂掉了。进而我关掉了服务器上所有的服务，并且重启了redis，继续刷入的时候成功了。这样就成功的莫名其妙。随后想了想。可能问题就是出在系统内存不够（开启了多个服务），并且在刷入行政区划时，还要持久化进硬盘中导致内存不够用抛出异常。这些等明天服务器重启时有待确认--关闭持久化rdb与aof。</p><p style=\"text-align: justify;\"><b>复习</b></p><p style=\"text-align: justify;\"><b>&nbsp; &nbsp;&nbsp;</b>进行配置时，突然发现自己还是有很多不会的，与记不清的，在这里先行记录一下，便于以后复习。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; 上面说到redis的淘汰策略，是在设置了maxmemory（redis最大内存限制）以后，如果数据溢出采用的相对应的策略，下面列出对应策略的数据处理方式。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; noeviction：达到内存限额后返回错误，客户尝试可以导致更多内存使用的命令（大部分写命令，但DEL和一些例外）</p><p style=\"text-align: justify;\">&nbsp; &nbsp; allkeys-lru：为了给新增加的数据腾出空间，驱逐键先试图移除一部分最近使用较少的（LRC）。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; volatile-lru：为了给新增加的数据腾出空间，驱逐键先试图移除一部分最近使用较少的（LRC），但只限于过期设置键。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; allkeys-random: 为了给新增加的数据腾出空间，驱逐任意键</p><p style=\"text-align: justify;\">&nbsp; &nbsp; volatile-random: 为了给新增加的数据腾出空间，驱逐任意键，但只限于有过期设置的驱逐键。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; volatile-ttl: 为了给新增加的数据腾出空间，驱逐键只有秘钥过期设置，并且首先尝试缩短存活时间的驱逐键</p><div><br></div>', '8', '0', '0', '1', '1', '1', '2019-06-24 19:07:56', '2019-06-24 19:07:56');
INSERT INTO `article` VALUES ('49', '3', '设计模式---策略模式', '<p><b>前言</b></p><p><b>&nbsp; &nbsp; </b>有关设计模式，平时自己也在尝试着接触，并且努力的将其写进自己的代码中去，今天就先说一个前一段儿时间刚刚写过的一个脚本生成的一小段代码。当时想起了顺带着可以联系以下设计模式，然后就找了找。突然响起了以前有关如何解决系统中if...else过多的解决方式中有一个策略模式，想了想还挺妥，于是最后选择了策略模式。</p><p><b>简介</b></p><p>意图</p><p><span>	</span>定义一系列的算法，把他们一个个封装起来，并且使他们可互相替换</p><p>主要解决</p><p><span>	</span>在有多种算法相似的情况下，使用if...else所带来的复杂和难以维护</p><p>何时使用</p><p><span>	</span>一个系统有许多许多类，而区分它们的只是他们的直接行为</p><p>如何解决</p><p><span>	</span>将这些算法封装成一个一个的类，任意的替换</p><p>应用实例</p><p><span>	</span>java AWT中layoutManager</p><p>优点</p><p><span>	</span>算法可以自由切换，避免使用多重条件去判断，扩展性良好</p><p>缺点</p><p>	策略类会增多，所有策略类都需要对外暴露</p><p><b>类图</b></p><p><b><img src=\"/uploads/2019/6/20190627211008.png\" alt=\"20190627211008.png\"><br></b></p><p><b>实例</b></p><p><b>&nbsp; &nbsp; </b>首先，我们需要一个抽象策略角色</p><p>public interface Strategy {</p><p><br></p><p><span>	</span>/**</p><p><span>	</span> * 删除语句</p><p><span>	</span> *&nbsp;</p><p><span>	</span> * @param param</p><p><span>	</span> * @version: v1.0.0</p><p><span>	</span> * @author: yangli</p><p><span>	</span> * @date: 2019年4月17日 上午11:10:56&nbsp;</p><p><span>	</span> *</p><p><span>	</span> */</p><p><span>	</span>void getDeleteResult(InterfaceParam param, String filePath);</p><p><span>	</span></p><p><span>	</span>/**</p><p><span>	</span> * 删除备份表语句</p><p><span>	</span> *&nbsp;</p><p><span>	</span> * @version: v1.0.0</p><p><span>	</span> * @author: yangli</p><p><span>	</span> * @date: 2019年4月17日 上午11:11:48&nbsp;</p><p><span>	</span> *</p><p><span>	</span> */</p><p><span>	</span>void getDeleteBackupsTables(InterfaceParam param, String filePath);</p><p><span>	</span></p><p><span>	</span>/**</p><p><span>	</span> * 备份语句</p><p><span>	</span> *&nbsp;</p><p><span>	</span> * @param param</p><p><span>	</span> * @version: v1.0.0<span></span><span></span><span></span><span>	</span></p><p><span>	</span> * @author: yangli</p><p><span>	</span> * @date: 2019年4月22日 上午9:16:51&nbsp;</p><p><span>	</span> *</p><p><span>	</span> */</p><p><span>	</span>void getBackupsResult(InterfaceParam param, String filePath);</p><p><span>	</span></p><p><span>	</span>/**</p><p><span>	</span> * 回滚语句</p><p><span>	</span> *&nbsp;</p><p><span>	</span> * @param param</p><p><span>	</span> * @version: v1.0.0</p><p><span>	</span> * @author: yangli</p><p><span>	</span> * @date: 2019年4月22日 上午9:17:31&nbsp;</p><p><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span>	</span>*<span></span><span>	</span></p><p style=\"text-align: left;\"><span>	</span> */</p><p><span>	</span>void getRollBackResult(InterfaceParam param, String filePath);</p><p><span>	</span></p><p>}</p><p><span style=\"text-align: justify;\">&nbsp; &nbsp; 由于其具体实现类中有共有的方法，于是我在抽象策略角色与具体实现中，又抽出了一层，ParentStratety抽象类来实现共有的方法</span></p><p style=\"text-align: justify;\">public abstract class ParentStrategy implements Strategy{</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>/**</p><p style=\"text-align: justify;\"><span>	</span> * 文件路径</p><p style=\"text-align: justify;\"><span>	</span> */</p><p style=\"text-align: justify;\"><span>	</span>protected Map&lt;String, String&gt; filepath;</p><p style=\"text-align: justify;\"><span>	</span>/**</p><p style=\"text-align: justify;\"><span>	</span> * 删除条件</p><p style=\"text-align: justify;\"><span>	</span> */</p><p style=\"text-align: justify;\"><span>	</span>protected String conditionOfDelete;</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>@Override</p><p style=\"text-align: justify;\"><span>	</span>public void getDeleteBackupsTables(InterfaceParam param, String filePath) {</p><p style=\"text-align: justify;\"><span>		</span>StringBuilder builder = new StringBuilder();</p><p style=\"text-align: justify;\"><span>		</span>String trance = \"\";</p><p style=\"text-align: justify;\"><span>		</span>builder.append(\"--\" + param.getInterfaceName() + \":\\r\\n\");</p><p style=\"text-align: justify;\"><span>		</span>for (String string : param.getParam()) {</p><p style=\"text-align: justify;\"><span>			</span>if (string.length() &gt;= 25) {</p><p style=\"text-align: justify;\"><span>				</span>trance = string.substring(0, 24);</p><p style=\"text-align: justify;\"><span>			</span>}else {</p><p style=\"text-align: justify;\"><span>				</span>trance = string;</p><p style=\"text-align: justify;\"><span>			</span>}</p><p style=\"text-align: justify;\"><span>			</span>builder.append(\"--数据库表:\" + string + \"\\r\\n\")</p><p style=\"text-align: justify;\"><span>				</span>.append(\"--删除备份表语句:\\r\\n\")</p><p style=\"text-align: justify;\"><span>				</span>.append(\"drop table \")</p><p style=\"text-align: justify;\"><span>				</span>.append(trance)</p><p style=\"text-align: justify;\"><span>				</span>.append(\"123;\");</p><p style=\"text-align: justify;\"><span>		</span>}</p><p style=\"text-align: justify;\"><span>		</span>JointUtil.createFile(builder.toString(), this.filepath.get(filePath));</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>public String getConditionOfDelete() {</p><p style=\"text-align: justify;\"><span>		</span>return conditionOfDelete;</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>public void setConditionOfDelete(String conditionOfDelete) {</p><p style=\"text-align: justify;\"><span>		</span>this.conditionOfDelete = conditionOfDelete;</p><p style=\"text-align: justify;\"><span>	</span>}</p><p><span style=\"text-align: justify;\"></span></p><p style=\"text-align: justify;\">}</p><p style=\"text-align: justify;\">&nbsp; &nbsp; 之后定义具体的实现类来继承当前所拥有的ParentStratety</p><p style=\"text-align: justify;\">/**</p><p style=\"text-align: justify;\">&nbsp;* 以传入名称等于特定条件，删除相关数据</p><p style=\"text-align: justify;\">&nbsp;*</p><p style=\"text-align: justify;\">&nbsp;* @author：yangli<span>	</span></p><p style=\"text-align: justify;\">&nbsp;* @date:2019年4月16日 上午11:37:04</p><p style=\"text-align: justify;\">&nbsp;* @version 1.0</p><p style=\"text-align: justify;\">&nbsp;*/</p><p style=\"text-align: justify;\">public class ContditionEqualsStrategy extends ParentStrategy{</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>public ContditionEqualsStrategy(Map&lt;String, String&gt; filePath, String conditionOfDelete) {</p><p style=\"text-align: justify;\"><span>		</span>this.filepath = filePath;</p><p style=\"text-align: justify;\"><span>		</span>this.conditionOfDelete = conditionOfDelete;</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>@Override</p><p style=\"text-align: justify;\"><span>	</span>public void getDeleteResult(InterfaceParam param, String filePath) {</p><p style=\"text-align: justify;\"><span>		</span>StringBuilder builder = new StringBuilder();</p><p style=\"text-align: justify;\"><span>		</span>builder.append(\"--\" + param.getInterfaceName() + \":\\r\\n\");</p><p style=\"text-align: justify;\"><span>		</span>for (String string : param.getParam()) {</p><p style=\"text-align: justify;\"><span>			</span>builder.append(getDeleteMessage(string));</p><p style=\"text-align: justify;\"><span>		</span>}</p><p style=\"text-align: justify;\"><span>		</span>JointUtil.createFile(builder.toString(), this.filepath.get(filePath));</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>private String getDeleteMessage(String interfaceName) {</p><p style=\"text-align: justify;\"><span>		</span>return \"--删除语句:\\r\\ndelete from \" + interfaceName + \" where \" + this.conditionOfDelete + \" = \'\';\\r\\n\";</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>@Override</p><p style=\"text-align: justify;\"><span>	</span>public void getBackupsResult(InterfaceParam param, String filePath) {</p><p style=\"text-align: justify;\"><span>		</span>StringBuilder builder = new StringBuilder();</p><p style=\"text-align: justify;\"><span>		</span>builder.append(\"--\" + param.getInterfaceName() + \":\\r\\n\");</p><p style=\"text-align: justify;\"><span>		</span>for (String string : param.getParam()) {</p><p style=\"text-align: justify;\"><span>			</span>builder.append(getBackupsMessage(string));</p><p style=\"text-align: justify;\"><span>		</span>}</p><p style=\"text-align: justify;\"><span>		</span>JointUtil.createFile(builder.toString(), this.filepath.get(filePath));</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>private String getBackupsMessage(String tableName) {</p><p style=\"text-align: justify;\"><span>		</span>StringBuilder builder = new StringBuilder();</p><p style=\"text-align: justify;\"><span>		</span>builder.append(\"--备份语句:\\r\\n\")</p><p style=\"text-align: justify;\"><span>			</span>.append(\"create table \")</p><p style=\"text-align: justify;\"><span>			</span>.append(JointUtil.getBackupsTableName(tableName))</p><p style=\"text-align: justify;\"><span>			</span>.append(\"_9415 as select * from \")</p><p style=\"text-align: justify;\"><span>			</span>.append(tableName)</p><p style=\"text-align: justify;\"><span>			</span>.append(\" where \" + this.conditionOfDelete + \" = \'200000\';\\r\\n\");</p><p style=\"text-align: justify;\"><span>		</span>return builder.toString();</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>@Override</p><p style=\"text-align: justify;\"><span>	</span>public void getRollBackResult(InterfaceParam param, String filePath) {</p><p style=\"text-align: justify;\"><span>		</span>StringBuilder builder = new StringBuilder();</p><p style=\"text-align: justify;\"><span>		</span>builder.append(\"--\" + param.getInterfaceName() + \":\\r\\n\");</p><p style=\"text-align: justify;\"><span>		</span>for (String string : param.getParam()) {</p><p style=\"text-align: justify;\"><span>			</span>builder.append(getRollBackMessage(string));</p><p style=\"text-align: justify;\"><span>		</span>}</p><p style=\"text-align: justify;\"><span>		</span>JointUtil.createFile(builder.toString(), this.filepath.get(\"roll\"));</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>private String getRollBackMessage(String tableName) {</p><p style=\"text-align: justify;\"><span>		</span>StringBuilder builder = new StringBuilder();</p><p style=\"text-align: justify;\"><span>		</span>builder.append(\"--回滚语句:\\r\\n\")</p><p style=\"text-align: justify;\"><span>			</span>.append(\"insert into \")</p><p style=\"text-align: justify;\"><span>			</span>.append(tableName)</p><p style=\"text-align: justify;\"><span>			</span>.append(\" as select * from \")</p><p style=\"text-align: justify;\"><span>			</span>.append(JointUtil.getBackupsTableName(tableName))</p><p style=\"text-align: justify;\"><span>			</span>.append(\"_9415;\\r\\n\");</p><p style=\"text-align: justify;\"><span>		</span>return builder.toString();</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\">}</p><p style=\"text-align: justify;\">另一个实现类</p><p style=\"text-align: justify;\">/**</p><p style=\"text-align: justify;\">&nbsp;* 以***进行批量删除</p><p style=\"text-align: justify;\">&nbsp;*</p><p style=\"text-align: justify;\">&nbsp;* @author：yangli<span>	</span></p><p style=\"text-align: justify;\">&nbsp;* @date:2019年4月16日 上午11:37:04</p><p style=\"text-align: justify;\">&nbsp;* @version 1.0</p><p style=\"text-align: justify;\">&nbsp;*/</p><p style=\"text-align: justify;\">public class BatchNoAndIDStrategy extends ParentStrategy{</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>/**</p><p style=\"text-align: justify;\"><span>	</span> * 关联条件，第一张表中的字段</p><p style=\"text-align: justify;\"><span>	</span> */</p><p style=\"text-align: justify;\"><span>	</span>private String firstJoinCondition;</p><p style=\"text-align: justify;\"><span>	</span>/**</p><p style=\"text-align: justify;\"><span>	</span> * 关联条件，第二张表中的字段</p><p style=\"text-align: justify;\"><span>	</span> */</p><p style=\"text-align: justify;\"><span>	</span>private String lastJoinCondition;</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>public BatchNoAndIDStrategy(Map&lt;String, String&gt; filePath, String firstJoinCondition, String lastJoinCondition) {</p><p style=\"text-align: justify;\"><span>		</span>this.filepath = filePath;</p><p style=\"text-align: justify;\"><span>		</span>this.firstJoinCondition = firstJoinCondition;</p><p style=\"text-align: justify;\"><span>		</span>this.lastJoinCondition = lastJoinCondition;</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>/**</p><p style=\"text-align: justify;\"><span>	</span> * 返回删除语句脚本</p><p style=\"text-align: justify;\"><span>	</span> *&nbsp;</p><p style=\"text-align: justify;\"><span>	</span> * @param param</p><p style=\"text-align: justify;\"><span>	</span> * @version: v1.0.0</p><p style=\"text-align: justify;\"><span>	</span> * @author: yangli</p><p style=\"text-align: justify;\"><span>	</span> * @date: 2019年4月22日 上午9:11:46&nbsp;</p><p style=\"text-align: justify;\"><span>	</span> *</p><p style=\"text-align: justify;\"><span>	</span> */</p><p style=\"text-align: justify;\"><span>	</span>@Override</p><p style=\"text-align: justify;\"><span>	</span>public void getDeleteResult(InterfaceParam param, String filePaht) {</p><p style=\"text-align: justify;\"><span>		</span>StringBuilder builder = new StringBuilder();</p><p style=\"text-align: justify;\"><span>		</span>builder.append(\"--\" + param.getInterfaceName() + \":\\r\\n\");</p><p style=\"text-align: justify;\"><span>		</span>String lastTableName = param.getParam()[0];</p><p style=\"text-align: justify;\"><span>		</span>for (int i = 1; i &lt; param.getParam().length; i ++) {</p><p style=\"text-align: justify;\"><span>			</span>builder.append(getDeleteMessage(param.getParam()[i], lastTableName));</p><p style=\"text-align: justify;\"><span>		</span>}</p><p style=\"text-align: justify;\"><span>		</span>JointUtil.createFile(builder.toString(), this.filepath.get(filePaht));</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>/**</p><p style=\"text-align: justify;\"><span>	</span> * 删除语句</p><p style=\"text-align: justify;\"><span>	</span> *&nbsp;</p><p style=\"text-align: justify;\"><span>	</span> * @param firstTableName</p><p style=\"text-align: justify;\"><span>	</span> * @param lastTableName</p><p style=\"text-align: justify;\"><span>	</span> * @return</p><p style=\"text-align: justify;\"><span>	</span> * @version: v1.0.0</p><p style=\"text-align: justify;\"><span>	</span> * @author: yangli</p><p style=\"text-align: justify;\"><span>	</span> * @date: 2019年4月22日 上午9:11:38&nbsp;</p><p style=\"text-align: justify;\"><span>	</span> *</p><p style=\"text-align: justify;\"><span>	</span> */</p><p style=\"text-align: justify;\"><span>	</span>private String getDeleteMessage(String firstTableName, String lastTableName) {</p><p style=\"text-align: justify;\"><span>		</span>return \"--删除语句:\\r\\ndelete from \"&nbsp;</p><p style=\"text-align: justify;\"><span>				</span>+ firstTableName&nbsp;</p><p style=\"text-align: justify;\"><span>				</span>+ \" resu where resu.\"</p><p style=\"text-align: justify;\"><span>				</span>+ this.firstJoinCondition&nbsp;</p><p style=\"text-align: justify;\"><span>				</span>+ \" in(select con.\"</p><p style=\"text-align: justify;\"><span>				</span>+ this.lastJoinCondition</p><p style=\"text-align: justify;\"><span>				</span>+ \" from \"</p><p style=\"text-align: justify;\"><span>				</span>+ lastTableName</p><p style=\"text-align: justify;\"><span>				</span>+ \" con where con.batchNo like \'%\');\\r\\n\";</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>@Override</p><p style=\"text-align: justify;\"><span>	</span>public void getBackupsResult(InterfaceParam param, String filePaht) {</p><p style=\"text-align: justify;\"><span>		</span>StringBuilder builder = new StringBuilder();</p><p style=\"text-align: justify;\"><span>		</span>builder.append(\"--\" + param.getInterfaceName() + \":\\r\\n\");</p><p style=\"text-align: justify;\"><span>		</span>String lastTableName = param.getParam()[0];</p><p style=\"text-align: justify;\"><span>		</span>for (int i = 1; i &lt; param.getParam().length; i ++) {</p><p style=\"text-align: justify;\"><span>			</span>builder.append(getBackupsMessage(param.getParam()[i], lastTableName));</p><p style=\"text-align: justify;\"><span>		</span>}</p><p style=\"text-align: justify;\"><span>		</span>JointUtil.createFile(builder.toString(), this.filepath.get(filePaht));</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>private String getBackupsMessage(String tableName, String lastTableName) {</p><p style=\"text-align: justify;\"><span>		</span>StringBuilder builder = new StringBuilder();</p><p style=\"text-align: justify;\"><span>		</span>builder.append(\"--备份语句:\\r\\n\")</p><p style=\"text-align: justify;\"><span>			</span>.append(\"create table dbbak.\")</p><p style=\"text-align: justify;\"><span>			</span>.append(JointUtil.getBackupsTableName(tableName))</p><p style=\"text-align: justify;\"><span>			</span>.append(\"_9415 as select * from \")</p><p style=\"text-align: justify;\"><span>			</span>.append(tableName)</p><p style=\"text-align: justify;\"><span>			</span>.append(\" resu where resu\")</p><p style=\"text-align: justify;\"><span>			</span>.append(this.firstJoinCondition)</p><p style=\"text-align: justify;\"><span>			</span>.append(\" in(select con.\")</p><p style=\"text-align: justify;\"><span>			</span>.append(this.lastJoinCondition)</p><p style=\"text-align: justify;\"><span>			</span>.append(\" from \")</p><p style=\"text-align: justify;\"><span>			</span>.append(lastTableName)</p><p style=\"text-align: justify;\"><span>			</span>.append(\" con where con.batchNo like \'AIIPTEST%\');\\r\\n\");</p><p style=\"text-align: justify;\"><span>		</span>return builder.toString();</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>@Override</p><p style=\"text-align: justify;\"><span>	</span>public void getRollBackResult(InterfaceParam param, String filePath) {</p><p style=\"text-align: justify;\"><span>		</span>StringBuilder builder = new StringBuilder();</p><p style=\"text-align: justify;\"><span>		</span>builder.append(\"--\" + param.getInterfaceName() + \":\\r\\n\");</p><p style=\"text-align: justify;\"><span>		</span>for (int i = 1; i &lt; param.getParam().length; i ++) {</p><p style=\"text-align: justify;\"><span>			</span>builder.append(getRollBackMessage(param.getParam()[i]));</p><p style=\"text-align: justify;\"><span>		</span>}</p><p style=\"text-align: justify;\"><span>		</span>JointUtil.createFile(builder.toString(), this.filepath.get(filePath));</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>private String getRollBackMessage(String tableName) {</p><p style=\"text-align: justify;\"><span>		</span>StringBuilder builder = new StringBuilder();</p><p style=\"text-align: justify;\"><span>		</span>builder.append(\"--回滚语句:\\r\\n\")</p><p style=\"text-align: justify;\"><span>			</span>.append(\"insert into \")</p><p style=\"text-align: justify;\"><span>			</span>.append(tableName)</p><p style=\"text-align: justify;\"><span>			</span>.append(\" as select * from dbbak.\")</p><p style=\"text-align: justify;\"><span>			</span>.append(JointUtil.getBackupsTableName(tableName))</p><p style=\"text-align: justify;\"><span>			</span>.append(\"_9415;\\n\\r\");</p><p style=\"text-align: justify;\"><span>		</span>return builder.toString();</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>public String getFirstJoinCondition() {</p><p style=\"text-align: justify;\"><span>		</span>return firstJoinCondition;</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>public void setFirstJoinCondition(String firstJoinCondition) {</p><p style=\"text-align: justify;\"><span>		</span>this.firstJoinCondition = firstJoinCondition;</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>public String getLastJoinCondition() {</p><p style=\"text-align: justify;\"><span>		</span>return lastJoinCondition;</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>public void setLastJoinCondition(String lastJoinCondition) {</p><p style=\"text-align: justify;\"><span>		</span>this.lastJoinCondition = lastJoinCondition;</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\">}</p><p style=\"text-align: justify;\">其次，我们还需要一个环境角色，持有一个抽象角色的引用，供外部进行调用</p><p style=\"text-align: justify;\">public class Context {</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>private Strategy strategy;</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>public Context(Strategy strategy) {</p><p style=\"text-align: justify;\"><span>		</span>this.strategy = strategy;</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>public void getDeleteResult(InterfaceParam param, String filePath) {</p><p style=\"text-align: justify;\"><span>		</span>strategy.getDeleteResult(param, filePath);</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>public void getBackupsResult(InterfaceParam param, String filePath) {</p><p style=\"text-align: justify;\"><span>		</span>strategy.getBackupsResult(param, filePath);</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>public void getRollBackResult(InterfaceParam param, String filePath) {</p><p style=\"text-align: justify;\"><span>		</span>strategy.getRollBackResult(param, filePath);</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\">}</p><p style=\"text-align: justify;\">最后，就是调用对外开放的环境类</p><p style=\"text-align: justify;\">public class Test {</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span>	</span>/**</p><p style=\"text-align: justify;\"><span>	</span> * 通过批次号进行删除:保单接口、批单接口、公共轨迹表、投保告知接口中存在批次号的表(INSURE_INFO)</p><p style=\"text-align: justify;\"><span>	</span> * <span>				</span>投保验证码接口、生成电子保批单、短信回执接口没问题</p><p style=\"text-align: justify;\"><span>	</span> * 通过保单号进行删除:条款备案信息上传接口没问题</p><p style=\"text-align: justify;\"><span>	</span> *&nbsp;</p><p style=\"text-align: justify;\"><span>	</span> * 投保告知接口-通过:MessageInfoTrance,MessageInfo,MessageInforReUpload</p><p style=\"text-align: justify;\"><span>	</span> * <span>				</span>要通过查询policyInformID-投保告知主信息表去进行联查删除</p><p style=\"text-align: justify;\"><span>	</span> *&nbsp;</p><p style=\"text-align: justify;\"><span>	</span> */</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>public static void main(String[] args) {</p><p style=\"text-align: justify;\"><span>		</span>Test test = new Test();</p><p style=\"text-align: justify;\"><span>		</span>test.getBackups();</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\"><span>	</span></p><p style=\"text-align: justify;\"><span>	</span>public void getBackups() {</p><p style=\"text-align: justify;\"><span>		</span>Map&lt;String, String&gt; filePath = new HashMap&lt;&gt;();</p><p style=\"text-align: justify;\"><span>		</span>filePath.put(\"back\", \"C:/Users/35923/Desktop/脚本/\");</p><p style=\"text-align: justify;\"><span>		</span>filePath.put(\"delete\", \"C:/Users/35923/Desktop/脚本/\");</p><p style=\"text-align: justify;\"><span>		</span>filePath.put(\"roll\", \"C:/Users/35923/Desktop/脚本/\");</p><p style=\"text-align: justify;\"><span>		</span>Context context = new Context(new ContditionEqualsStrategy(filePath, \"\"));</p><p style=\"text-align: justify;\"><span>		</span>context.getBackupsResult(InterfaceParam.ODS_ORACLE, \"back\");</p><p style=\"text-align: justify;\"><span>		</span>context.getDeleteResult(InterfaceParam.ODS_ORACLE, \"delete\");</p><p style=\"text-align: justify;\"><span>		</span>context.getRollBackResult(InterfaceParam.ODS_ORACLE, \"roll\");</p><p style=\"text-align: justify;\"><span>		</span></p><p style=\"text-align: justify;\"><span>		</span>Map&lt;String, String&gt; filePath1 = new HashMap&lt;&gt;();</p><p style=\"text-align: justify;\"><span>		</span>filePath1.put(\"back\", \"C:/Users/35923/Desktop/脚本/\");</p><p style=\"text-align: justify;\"><span>		</span>filePath1.put(\"delete\", \"C:/Users/35923/Desktop/脚本/\");</p><p style=\"text-align: justify;\"><span>		</span>filePath1.put(\"roll\", \"C:/Users/35923/Desktop/脚本/\");</p><p style=\"text-align: justify;\"><span>		</span></p><p style=\"text-align: justify;\"><span>		</span>Context context1 = new Context(new ContditionEqualsStrategy(filePath1, \"companycode\"));</p><p style=\"text-align: justify;\"><span>		</span>context1.getBackupsResult(InterfaceParam.AIPEFFECTIVE, \"back\");</p><p style=\"text-align: justify;\"><span>		</span>context1.getDeleteResult(InterfaceParam.AIPEFFECTIVE, \"delete\");</p><p style=\"text-align: justify;\"><span>		</span>context1.getRollBackResult(InterfaceParam.AIPEFFECTIVE, \"roll\");</p><p style=\"text-align: justify;\"><span>	</span>}</p><p style=\"text-align: justify;\">}</p><p style=\"text-align: justify;\"><b>总结</b></p><p style=\"text-align: justify;\"><b>&nbsp; &nbsp; </b>策略模式正如上述所说，可以根据不同的要求去实现对应的策略实现类，并且通过同统一对外开放的环境类对其进行调用，在了解过程中，策略类的缺点也很明显，每个要求都要实现一个策略类，这样，后期就会有大量的策略类，导致难以维护。所以应根据实际情况去选择相应的设计模式</p><p style=\"text-align: justify;\">&nbsp; &nbsp; 设计模式并不是一个死板的样例，仅仅会使用就可以了，他更多的同其他设计模式一样，体现了对需求的抽象能力。虽然可能在初学时，难以看懂，但是在运用熟练之后，确实对自己以后的代码设计编写是一个很大的帮助。设计模式更好的遵循了java的设计原则，他不仅仅能帮助我们更好的去理解那些原则知识，也更好的帮助了我们代码的美观度及可扩展性。所以说，还是要多看多多想。</p>', '7', '0', '0', '1', '1', '1', '2019-06-27 21:34:44', '2019-06-27 21:34:44');
INSERT INTO `article` VALUES ('50', '3', '有关weblogic与jdk一个特性的冲突', '<p><b>问题背景</b></p><p><b>&nbsp; &nbsp; </b>最近在对我们的监管系统进行二次开发，weblogic版本为12.1.1.0，jdk版本为1.8。项目为常见的spring+springMVC+hibernate。</p><p><b>问题</b></p><p><b>&nbsp; &nbsp; </b>利用maven打包项目后，直接连部署也部署不上了，报一下的错误</p><p>&nbsp; &nbsp;&nbsp;<img src=\"/uploads/2019/7/20190703142148(1).png\" alt=\"20190703142148.png\"><br></p><p>&nbsp; &nbsp; 并且多次尝试部署时，还会时不时的提示我数组越界（项目中的数组并未越界，并且还未到项目运行阶段）。后台会提示我嵌套异常</p><p><b>问题分析</b></p><p><b>&nbsp; &nbsp; </b>根据错误信息去网上搜了一下，发现都是说web.xml出现了weblogic上不支持的标签，并且大多数都是复制粘贴别人的。千篇一律的答案。因为项目还是以前的web.xml。因此我排除了这个错误。</p><p>&nbsp; &nbsp; 在统计结果查询那块儿，用到了多线程及线程池，这也都是项目里以前拥有的，只不过就是单独写了线程实现方法。</p><p>&nbsp; &nbsp; 于是，我把问题的目光放到了我刚采用的lambda表达式。因为以前没有用过，并且也是1.8，所以我就打算采用以下，毕竟会简化代码。</p><p>&nbsp; &nbsp; 果然，当我将刚刚写完的代码其余部分注释掉，并且将其中一段lambda修改为全量写法。项目就部署成功了</p><p><b>问题记录</b></p><p><b>&nbsp; &nbsp; </b>不知道为什么，就是简单的写一个lambda就出现了项目部署错误，并且网上没有任何相关的资料说明weblogic不支持lambda表达式</p><p>&nbsp; &nbsp; 目前仅仅找到了问题的所在。解决办法也是将lambda替换成对应的代码段。</p><p>&nbsp; &nbsp; 最后想到了一个问题，就是以前听说过weblogc的执行war包的方式和tomcat不一样，由于对于weblogc不是很熟悉，等到以后有时间了再研究一下子。</p><p>&nbsp; &nbsp; 暂时只能确定weblogic12.1.1.0版本与lambda表达式会出现冲突，可能由于weblogic独特的执行war包的机制导致。</p><p>&nbsp; &nbsp; 如果有人能够解决或者以后有时间去看一下，解决方法写入这篇下方评论。</p>', '4', '0', '0', '1', '1', '1', '2019-07-08 15:44:07', '2019-07-08 15:44:07');
INSERT INTO `article` VALUES ('51', '3', '字符串批量替换子字符串', '<p><b>问题</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>最近写代码的时候，碰到了一个小问题，数据库中一个字段存储了该条数据的各种包含的类型，以“,”逗号隔开。例如：1，5，6，7</p><p>&nbsp; &nbsp; 页面展示中，却要求其转化为相应的文字描述，这些描述在一个码表中进行存储。1：业务类 2：影像类 3：财务类等等</p><p><b>解决方法</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>在apache的包下，有一个Stringutils。<a class=\"header\" href=\"eclipse-javadoc:%E2%98%82=agro-ins-web/webapp%5C/WEB-INF%5C/lib%5C/commons-lang-2.6.jar%3Corg\">org</a>.<a class=\"header\" href=\"eclipse-javadoc:%E2%98%82=agro-ins-web/webapp%5C/WEB-INF%5C/lib%5C/commons-lang-2.6.jar%3Corg.apache\">apache</a>.<a class=\"header\" href=\"eclipse-javadoc:%E2%98%82=agro-ins-web/webapp%5C/WEB-INF%5C/lib%5C/commons-lang-2.6.jar%3Corg.apache.commons\">commons</a>.<a class=\"header\" href=\"eclipse-javadoc:%E2%98%82=agro-ins-web/webapp%5C/WEB-INF%5C/lib%5C/commons-lang-2.6.jar%3Corg.apache.commons.lang\">lang</a>.StringUtils这个类中，有一个replaceEach方法</p><p>&nbsp; &nbsp; 该方法的参数为（字符串，数组，数组），即原始字符串，将要替换掉的字符串与结果字符串传入即可。</p><p>&nbsp; &nbsp;&nbsp;<img src=\"http://www.yangdali.cn:8080/uploads/2019/7/20190708160540(1).png\" alt=\"20190708160540.png\"><br></p><p>&nbsp; &nbsp;&nbsp;</p>', '7', '2', '0', '1', '1', '1', '2019-07-08 16:58:16', '2019-07-08 16:58:16');
INSERT INTO `article` VALUES ('52', '3', '【转】Tomcat启动时卡在“INFO: Deploying web application directory ......”的解决方法', '<p><b>前言</b></p><p>&nbsp; &nbsp; 点开以前保存的网址，突然看到了这个，就想起来了刚刚开始在云服务器上部署tomcat时，总是突然间就卡住不动了，最后通过该篇博客解决了问题，在此记录一下。省的以后忘记。</p><p><b>正文</b></p><p>第一次遇到Tomcat在Linux服务器启动卡住的情况，情况很简单，tomcat启动以后卡在INFO: Deploying web application directory ......这句话，具体会卡多久就没测试了。google、baidu都没找到解决方法。</p><p><br></p><p>幸亏UCloud的技术支持人员给出了解决方案。</p><p><br></p><p>找到jdk1.x.x_xx/jre/lib/security/java.security文件，在文件中找到securerandom.source这个设置项，将其改为：</p><p><br></p><p>securerandom.source=file:/dev/./urandom</p><p><br></p><p>这时候根据修改内容就可以查到因为此原因不仅可以造成tomcat卡住，也会造成weblogic启动缓慢，</p><p><br></p><p><br></p><p><br></p><p>linux或者部分unix系统提供随机数设备是/dev/random 和/dev/urandom ，两个有区别，urandom安全性没有random高，但random需要时间间隔生成随机数。jdk默认调用random。</p><p><br></p><p><br></p><p>再后来，终于在weblogic的官方文档中 Monitoring and Troubleshooting 找到了 Avoiding JVM Delays Caused By Random Number Generation 这样一个标题。摘录如下：</p><p><br></p><p>The library used for random number generation in Sun\'s JVM relies on /dev/random by default for UNIX platforms. This can potentially block the Oracle WebLogic Communication Services process because on some operating systems /dev/random waits for a certain amount of \"noise\" to be generated on the host machine before returning a result. Although /dev/random is more secure, Oracle recommends using /dev/urandom if the default JVM configuration delays Oracle WebLogic Communication Services startup.</p><p><br></p><p>To determine if your operating system exhibits this behavior, try displaying a portion of the file from a shell prompt:</p><p><br></p><p>head -n 1 /dev/random</p><p>Open the $JAVA_HOME/jre/lib/security/java.security file in a text editor.</p><p><br></p><p>Change the line:</p><p><br></p><p>securerandom.source=file:/dev/random</p><p>to read:</p><p><br></p><p>securerandom.source=file:/dev/urandom</p><p>Save your change and exit the text editor.</p><p>其中说到：可通过 head -n 1 /devrandom 查看是否你的系统会出现伪随机数提供等待。OK就这个，试了一下，果然，在服务器第一次启动后，这个可以快速提供一个值，但当再次调用时发生等待。</p><p><br></p><p><br></p><p>解决办法：</p><p><br></p><p><br></p><p>永久：oracle 说修改 $JAVA_HOME/jre/lib/security/java.security 文件，替换securerandom.source=file:/dev/random 为 securerandom.source=file:/dev/urandom。对所有使用JVM的应用生效。（这个永久的方法，这里面有个问题，就是设置时候实际应该设置为securerandom.source=file:/dev/./urandom，否则不生效）</p><p><br></p><p><br></p><p>DOMAIN临时：修改startWeblogic.sh文件，JAVA_OPTIONS=\"${SAVE_JAVA_OPTIONS} -Djava.security.egd=file:/dev/./urandom\"</p><p><br></p><p><br></p><p>后继的SecureRandom 测试学习</p><p><br></p><p><br></p><p>编写JAVA类如下，运行测试，第一次正常，第二次等待，重启服务器后第一次又正常。启动加入参数 -Djava.security.egd=file:/dev/./urandom 正常</p><p><br></p><p>原文：https://blog.csdn.net/njchenyi/article/details/46641141&nbsp;</p>', '11', '0', '1', '1', '1', '1', '2019-07-10 16:25:53', '2019-07-10 16:25:53');
INSERT INTO `article` VALUES ('53', '3', '有关本地服务内存溢出问题及常见问题总结', '<p><b>问题</b></p><p>&nbsp; &nbsp; 今天在本地起服务，来测试写的一段读取txt文件并且收录入库的过程中，测试五十万数据的时候竟然内存溢出了。好不容易出现了一次，我就赶紧按照我的理论分析了一下子。</p><p><b>问题分析</b></p><p><b>&nbsp; &nbsp;&nbsp;java.lang.OutOfMemoryError: GC overhead limit exceeded</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>这是该问题抛出的具体异常信息，这个错误其实对于以前看过内存溢出的我也是一脸懵逼。上网百度了一下。具体的错误信息为：GC占用了多余98%（默认值）的CPU时间却只回收了少于2%（默认值）的堆空间。</p><p>&nbsp; &nbsp; 看到这个错误信息时，立马就意识到了，在读取txt文件时，每行文件都会创建一个对象，用与存库使用。为了避免内存溢出，在解析的过程中，每500条进行入库操作。在解析入库的操作中，不断的创建对象，并且在使用一次后就将其丢弃。正如上面所说的那个场景一样，占用了百分之九十八的时间进行回收，但是仅仅只回收了一点内存空间</p><p>&nbsp; &nbsp; 在碰到这个问题时，我们应该考虑的是程序中是否有一瞬间大量持续的创建对象。</p><p><b>解决办法</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>这个问题在本地时，我是修改了Heap Size -Xmx2G，增大了内存的堆空间进行解决。因为在本地测试时，由于内存设置过小，导致解析过程中内存很快被占满，但是GC在回收过程中，又不能很快的释放这些对象。</p><p>&nbsp; &nbsp; 网上提供了一个屏蔽这个错误的配置属性：-XX:UseGCOverheadLimit&nbsp; 这个配置在于可以屏蔽掉开始JVM报出的那个错误。但是也有人指出了，在屏蔽掉这个错误以后，会产生很大的隐患问题。JVM在抛出<b>GC overhead limit exceeded</b>这个错误时，就是为了提示用户尽快的排查相关内存问题。他并不能从根本上解决内存溢出的这个严重的后果。如果添加上这个参数。那么只会把内存溢出的时间延后，并且封装成更常见的java.lang.OutOfMemoryError: Java heap space 错误信息，使得排查问题上更加复杂。</p><p>&nbsp; &nbsp; 以上是通过加大内存，暂时的解决掉了这个可能溢出的风险。回头看来。在解析过程中，如果数据量增大。就会创建很多个一次性对象用于存放每一条解析数据。经过思考以后，我又想到了类似于线程池的这种池化解决方案。利用对象池，创建一个集合，在开始解析时，创建一个静态集合（确保不会被回收），存放每次解析的数据，在循环一次后，清空这些对象属性，并且复用这些对象。在整体文件解析完成后，统一释放这些对象，或者设置对象过期时间，将其从静态集合中释放。这样，就不会出现GC一次后，仍然有大量的无用对象等待回收。不过这个方案还待实现。</p>', '2', '0', '0', '1', '1', '1', '2019-08-28 16:01:22', '2019-07-26 16:43:22');
INSERT INTO `article` VALUES ('54', '3', 'ThreadLocal有关的一些问题的探讨', '<p><b>ThreadLocal是什么?</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>ThreadLocal是用来维护线程中的变量不被其他线程所影响而出现一个一种结构，内部包含一个ThreadLocalMap内部类（内部包含一个Entry内部类），该类为Thread的一个局部变量，该Map存储的key为ThreadLocal对象自身，value为我们要储存的对象。这样一来，在不同的线程中，持有的其实都是当前线程的变量副本，与其他线程完全隔离，以此来保证执行过程中不受其他线程的影响。</p><p>&nbsp; &nbsp; 在jdk源码中，ThreadLocal类上面的注释这样说到：该类提供了线程局部变量。这些变量不同于他们的普通对应物，因为访问某个变量（通过get/set方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。Threads实例通常是类中的private static字段，他们希望将状态与某一个线程相关联。</p><p>&nbsp; &nbsp; 注释表达了这么几种观点：</p><p>&nbsp; &nbsp; 1.ThreadLocal不是线程，仅仅是线程的一个变量</p><p>&nbsp; &nbsp; 2.ThreadLocal在类中通常定义为私有的静态变量</p><p>&nbsp; &nbsp; 3.每个线程都有一个自己的ThreadLocal，他是变量的一个拷贝，修改不影响其他线程</p><p>&nbsp; &nbsp; 以前仅仅是记住了ThreadLocal是线程的局部变量，但是在看完源码以后，它更像是一个操作线程内部变量的一个工具类。</p><p>&nbsp; &nbsp; 曾经也在一篇网上说Spring，Hibernate等框架中的管理request作用域的Bean、事务管理、任务调度、AOP模块都出现了ThreadLocal的身影，所以下决心好好过一边源码。</p><p><b>ThreadLocal方法及使用:</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>ThreadLocal中有四个我们常用的方法：</p><p>&nbsp; &nbsp; ·public T get():返回此线程局部变量的当前线程副本中的值</p><p>&nbsp; &nbsp; ·void set(T value):设置当前线程的线程局部变量的值</p><p>&nbsp; &nbsp; ·public void remove():将当前线程局部变量的值删除，目的是为了减少内存的占用，它可以加快内存回收的速度。另一方面，在我们常用线程池的现在，由于线程池对于线程的复用，如果不手动清楚线程局部变量，那么会存在在线程池复用该线程时，如果没有调用set()方法设置初始值，就可能会get()到重用线程的信息，包括ThreadLocal所关联的线程对象的value值</p><p>&nbsp; &nbsp; ·protected Object initialValue():返回该线程局部变量的初始值，该方法时要给protected的方法，显然是为了让子类覆盖而设计的。注意：这个方法是一个延迟调用的方法，在线程第一次调用get()或者set()方法时才执行，并且仅执行一次。ThreadLocal中的缺省实现直接返回一个null。</p><p><b>ThreadLocal源码说明：</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>既然说ThreadLocal是线程的一个局部变量，而我也将其理解为操作线程局部变量的一个工具类，就在于ThreadLocalMap---这个ThreadLocal中的一个内部类。</p><p>&nbsp; &nbsp; 在ThreadLocal中，定义的ThreadLocal是这么解释该内部类的：</p><p>&nbsp; &nbsp;&nbsp;<span data-group=\"0-0\" class=\"transSent\">ThreadLocalMap是一个定制的散列映射，只适合维护线程本地值。</span><span data-group=\"0-1\" class=\"transSent\">在ThreadLocal类之外不导出任何操作。</span><span data-group=\"0-2\" class=\"transSent\">类是包私有的，允许在类线程中声明字段。</span><span data-group=\"0-3\" class=\"transSent\">为了帮助处理非常大且长期存在的使用，哈希表条目使用WeakReferences作为键。</span><span data-group=\"0-4\" class=\"transSent\">但是，由于不使用引用队列，所以只有当表开始耗尽空间时，才保证删除陈旧的条目。</span></p><p><span data-group=\"0-4\" class=\"transSent\">&nbsp; &nbsp; ThreadLocal去定义了ThreadLocalMap，而在线程Thread中，使用了ThreadLocalMap去存放每个线程的局部变量</span></p><p><span data-group=\"0-4\" class=\"transSent\">&nbsp; &nbsp;&nbsp;<img src=\"/uploads/2019/8/20190807203205.png\" alt=\"20190807203205.png\"></span></p><p><span data-group=\"0-4\" class=\"transSent\">&nbsp; &nbsp; 在ThreadLocal类中，不管是set()方法还是get()方法，都会有共同的一句代码，那就是：</span></p><p>&nbsp; &nbsp; &nbsp; &nbsp; Thread t = Thread.currentThread();</p><p><span data-group=\"0-4\" class=\"transSent\"></span></p><p>&nbsp; &nbsp; &nbsp; &nbsp; ThreadLocalMap map = getMap(t);</p><p>&nbsp; &nbsp; 首先会获取到当前线程中的ThreadLocalMap，然后再去进行操作。因此，最后不管是赋值也好，获取值也好，都是对于某个线程中的局部变量threadlocals来说的。因此ThreadLoca是用来实现线程之间不可见的一个结构，而我也将其认为是操作线程本身中的ThreadLocalMap的工具类。</p><p>&nbsp; &nbsp; 而在ThreadLocaMap中，线程作为key值，而存储数据的，则是它其中的一个内部类Entry。Entry的数据结构非常简单，仅仅是继承了WeakReference<t>类(弱引用)</t></p><p>&nbsp; &nbsp;&nbsp;<img src=\"/uploads/2019/8/20190807204022.png\" alt=\"20190807204022.png\"></p><p><span data-group=\"0-4\" class=\"transSent\"><br></span></p><p><span data-group=\"0-4\" class=\"transSent\">&nbsp; &nbsp; 从这里我们不难理解出ThreadLocal究竟是如何工作的了：</span></p><p><span data-group=\"0-4\" class=\"transSent\">&nbsp; &nbsp; 1.Thread类中有一个成员变量ThreadLocalMap,他是一个Map,他的Key事ThreadLocal类</span></p><p><span data-group=\"0-4\" class=\"transSent\">&nbsp; &nbsp; 2.每个线程拥有自己的声明为ThreadLocal类型的变量，这个类的名字叫TreadLocal：线程自己的变量.</span></p><p><span data-group=\"0-4\" class=\"transSent\">&nbsp; &nbsp; 3.此变量声明周期是由该线程决定的，开始于第一次初始化（get/set方法）。</span></p><p><span data-group=\"0-4\" class=\"transSent\">&nbsp; &nbsp; 4.由TreadLocal的工作原理决定了：每个线程独自拥有一个变量，并非共享或者是拷贝</span></p><p><span data-group=\"0-4\" class=\"transSent\"><b>ThradLocal解决的一些问题：</b></span></p><p><span data-group=\"0-4\" class=\"transSent\"><b>&nbsp; &nbsp; </b>hibernate框架中,对于并发访问数据库获取session时，采用了ThreadLocal来解决问题</span></p><p><span data-group=\"0-4\" class=\"transSent\">&nbsp; &nbsp;&nbsp;<img src=\"/uploads/2019/8/20190807210741.png\" alt=\"20190807210741.png\"><br></span></p><p><span data-group=\"0-4\" class=\"transSent\">&nbsp; &nbsp; 这样的好处就是介于singleton与prptotye之间，应用单例无法解决并发问题，应用多例开销又太大，对于线程所使用的变量用ThreadLocal，而该类的实例方法均可以共享。</span></p><p><span data-group=\"0-4\" class=\"transSent\"><b>ThreadLocal的一些不足之处：</b></span></p><p>1.上面已经提到了，由于现在线程池的使用，会复用Thread对象，那么Thread绑定的类的静态属性ThreadLocal变量也会被重用。如果在实现的线程run()方法体中不显示的效用remove()清理与线程相关的ThreadLocal信息，那么下一次如果不显示的调用set进行复赋值，就可能get()到重用的线程信息。下面是《码出高效》里面的一个关于threadlocal的一个例子，大家可以参考一下</p><p><img src=\"/uploads/2019/8/0190807212043.png\" alt=\"0190807212043.png\"><br></p><p>2.内存泄漏</p><p>在jdk源码的ThreadLocal的注释中写道，常用private static来修饰ThreadLocal。在此场景下，如果不显示的调用remove()操作，那么这个线程执行完成后，通过ThreadLocal对象持有的T对象是不会被释放的，从而引起内存泄漏问题</p><p>以上两个问题，都是在使用ThreadLocal后未手动清除的原因，因此，在每次使用完后，都要显式的调用remove()来清除线程中的对于ThreadLocal的引用。</p>', '5', '0', '0', '1', '1', '1', '2019-08-07 21:27:51', '2019-08-06 16:27:28');
INSERT INTO `article` VALUES ('55', '3', '有关for循环与foreach增强循环的一些问题与见解', '<p><b>前言</b></p><p>&nbsp; &nbsp; 今天项目组代码评审的时候，对于一个人在foreach前判断了集合是否为空大家产生了异议。对于这个问题。我也记忆的不是很清楚。因为当时是依稀记得foreach底层调用的是集合的Iterator的迭代器去对集合遍历的。如果不进行判断的话，如果集合为null的话，肯定是会抛出空指针异常的。因此今天闲了下来，顺便回顾一下集合利用for循环与增强for循环的区别。</p><p><b>for与foreach</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>其实这两个循环可能是大家刚刚接触到java就会学习到的一个基础知识点。</p><p>&nbsp; &nbsp; for循环可能会很好理解一些。通过控制局部变量\'i\'来控制循环的次数。并且以局部变量\'i\'作为下标去集合中获取该下标所对应的值，这样做的一些优缺点如下：</p><p>&nbsp; &nbsp; 1.根据下标取值，在ArrayList集合（底层数据结构为数组）会很快。在数据量达到一定量级，其速度会超过利用Iterator迭代器去便利集合的速度，在LinkedList中，当然效率略有底下（由于数据结构为链表。每次获取下标为‘i’的值时，都会从头部或者尾部开始遍历）。</p><p><br></p><p>&nbsp; &nbsp; foreach循环是java5所添加的新特性。看到他的代码格式可能一脸懵逼，但是将java所生成的class文件反编译后，我们就会发现，foreach底层其实是调用了Iterator迭代器。跟我们利用迭代器去便利集合的写法几乎一样。（有兴趣的可以自己写一个查看其字节码文件）。优缺点如下：</p><p>&nbsp; &nbsp; 1.根据迭代器去便利集合，在我们常用的ArrayList集合上，数据量少的情况下，速度与for循环持平，数据量大时，速度会稍稍低于for循环。</p><p>&nbsp; &nbsp; 2.去遍历以链表为底层数据结构的集合时，效率将大大提升。</p><p><b>其他问题</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>其实在最开始的那个问题上,由于集合是底层公司封装的框架给返回的。没有看过代码的人，就会认为其存在返回null的这种可能，并且对集合进行判断，防止了空指针的出现。我认为这样是正确的。</p><p>&nbsp; &nbsp; 在《码出高效》的异常那一节，曾经对于预防类似于空指针的这样的问题到底是服务方还是调用方的责任进行了阐述。如果服务方明确的说明不会返回null。那么调用方就不用进行判断了么？这当然是否定的。书上针对于该场景说明了具体的情况。并且最后得出的结论是：契约式编程理念完全处于防御式编程理念的下方。防止NPE一定是调用方的责任，需要调用方事先进行判断。</p><p>&nbsp; &nbsp; 另一个问题就是在阿里巴巴的编程规范中写道了这样一条</p><p>&nbsp; &nbsp; 不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。</p><p>&nbsp; &nbsp; 最后经过测试会发现，在foreach循环中add/remove集合元素时，有时会抛出ConcurrentModificationException异常。有兴趣的大佬可以去深追一下这个异常产生的原因。</p>', '7', '0', '0', '1', '1', '1', '2019-08-28 15:07:13', '2019-08-28 15:07:13');
INSERT INTO `article` VALUES ('56', '3', '为什么不能根据返回类型来区分重载', '<p><b>前言</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>今天在看别的网站的时候突然看到这么一句话“为什么不能根据返回类型来区分重载”。刚开始一下没反应过来。因此在这里记录一下。</p><p><b>重载</b></p><p><b>&nbsp;&nbsp;</b>&nbsp; 重载是在一个类里面，方法名字相同，参数列表不同，并且可以改变修饰符与返回值类型。</p><p><b>问题</b></p><p><b>&nbsp; &nbsp;&nbsp;</b>其实都知道重载是以上那个规则，但是到底为什么不能根据返回值类型区分呢？</p><p>&nbsp; &nbsp; 首先。我们要知道一点，重载是java多态的一种体现，它是编译时的多态</p><p>&nbsp; &nbsp; 举个例子：</p><p>&nbsp; &nbsp; String test(int param);</p><p>&nbsp; &nbsp; Integer test(int param);</p><p>&nbsp; &nbsp; 如果不需要返回值，直接调用test(...);方法，你知道是调用的哪个么，当然不知道。</p><p>&nbsp; &nbsp; 另外在java虚拟机中也提到了：在java语言中，要重载（Overload）一个方法，除了要与原方法具有相同简单的名称之外，还要求必须有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的返回更大一些，只要描述符不是完全一致的两个方法也可以共存。也就是说。如果两个方法具有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于一个class文件中的。</p><p>&nbsp; &nbsp; 以上一段话就引出了一个更有趣的问题，那就是在编译完成后的Class文件中，是允许两个方法方法名与参数列表相同，但返回值不同的。</p><p>&nbsp; &nbsp; 我们先说一下不同层面特征签名的区别。</p><p>&nbsp; &nbsp; 1.java语言层面的方法特征签名</p><p>&nbsp; &nbsp; 特征签名 = 方法名 + 参数类型 + 参数顺序；</p><p>&nbsp; &nbsp; 2.jvm层面的方法特征签名：</p><p>&nbsp; &nbsp; 特征签名 = 方法名 + 参数类型 + 参数顺序 + 返回值类型；</p><p>&nbsp; &nbsp; 这样，将两个除过方法名字不同，其他都一直的方法经过编译以后，手动修改class文件中的方法名字，那么，在方法内部将方法名字输出以后，就会发现能过执行，并且方法名字一致。</p><p>&nbsp; &nbsp; 这里，就证明了：Class文件中有两个同名同参数（类型，顺序都一致），但返回值类型不一样的方法也是允许的，可以正常运行。</p>', '2', '0', '0', '1', '1', '1', '2019-09-04 06:48:04', '2019-09-04 06:48:04');

-- ----------------------------
-- Table structure for article_category_ref
-- ----------------------------
DROP TABLE IF EXISTS `article_category_ref`;
CREATE TABLE `article_category_ref` (
  `article_id` int(11) DEFAULT NULL,
  `category_id` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article_category_ref
-- ----------------------------
INSERT INTO `article_category_ref` VALUES ('35', '15');
INSERT INTO `article_category_ref` VALUES ('35', '16');
INSERT INTO `article_category_ref` VALUES ('36', '15');
INSERT INTO `article_category_ref` VALUES ('36', '17');
INSERT INTO `article_category_ref` VALUES ('37', '1');
INSERT INTO `article_category_ref` VALUES ('37', '2');
INSERT INTO `article_category_ref` VALUES ('38', '10');
INSERT INTO `article_category_ref` VALUES ('38', '11');
INSERT INTO `article_category_ref` VALUES ('39', '1');
INSERT INTO `article_category_ref` VALUES ('39', '8');
INSERT INTO `article_category_ref` VALUES ('41', '1');
INSERT INTO `article_category_ref` VALUES ('41', '2');
INSERT INTO `article_category_ref` VALUES ('42', '1');
INSERT INTO `article_category_ref` VALUES ('42', '2');
INSERT INTO `article_category_ref` VALUES ('40', '100000007');
INSERT INTO `article_category_ref` VALUES ('44', '1');
INSERT INTO `article_category_ref` VALUES ('44', '7');
INSERT INTO `article_category_ref` VALUES ('45', '1');
INSERT INTO `article_category_ref` VALUES ('45', '7');
INSERT INTO `article_category_ref` VALUES ('46', '1');
INSERT INTO `article_category_ref` VALUES ('46', '7');
INSERT INTO `article_category_ref` VALUES ('47', '1');
INSERT INTO `article_category_ref` VALUES ('47', '2');
INSERT INTO `article_category_ref` VALUES ('43', '1');
INSERT INTO `article_category_ref` VALUES ('43', '2');
INSERT INTO `article_category_ref` VALUES ('48', '15');
INSERT INTO `article_category_ref` VALUES ('48', '17');
INSERT INTO `article_category_ref` VALUES ('49', '1');
INSERT INTO `article_category_ref` VALUES ('49', '6');
INSERT INTO `article_category_ref` VALUES ('50', '1');
INSERT INTO `article_category_ref` VALUES ('50', '2');
INSERT INTO `article_category_ref` VALUES ('51', '10');
INSERT INTO `article_category_ref` VALUES ('51', '11');
INSERT INTO `article_category_ref` VALUES ('52', '1');
INSERT INTO `article_category_ref` VALUES ('52', '8');
INSERT INTO `article_category_ref` VALUES ('54', '1');
INSERT INTO `article_category_ref` VALUES ('54', '4');
INSERT INTO `article_category_ref` VALUES ('55', '1');
INSERT INTO `article_category_ref` VALUES ('55', '2');
INSERT INTO `article_category_ref` VALUES ('53', '1');
INSERT INTO `article_category_ref` VALUES ('53', '7');
INSERT INTO `article_category_ref` VALUES ('56', '1');
INSERT INTO `article_category_ref` VALUES ('56', '7');

-- ----------------------------
-- Table structure for article_copy
-- ----------------------------
DROP TABLE IF EXISTS `article_copy`;
CREATE TABLE `article_copy` (
  `article_id` int(11) NOT NULL AUTO_INCREMENT,
  `article_user_id` int(11) unsigned DEFAULT NULL,
  `article_title` varchar(255) DEFAULT NULL,
  `article_content` mediumtext,
  `article_view_count` int(11) DEFAULT '0',
  `article_comment_count` int(11) DEFAULT '0',
  `article_like_count` int(11) DEFAULT '0',
  `article_is_comment` int(1) unsigned DEFAULT NULL,
  `article_status` int(1) unsigned DEFAULT '1',
  `article_order` int(11) unsigned DEFAULT NULL,
  `article_update_time` datetime DEFAULT NULL,
  `article_create_time` datetime DEFAULT NULL,
  PRIMARY KEY (`article_id`)
) ENGINE=MyISAM AUTO_INCREMENT=35 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article_copy
-- ----------------------------

-- ----------------------------
-- Table structure for article_tag_ref
-- ----------------------------
DROP TABLE IF EXISTS `article_tag_ref`;
CREATE TABLE `article_tag_ref` (
  `article_id` int(11) NOT NULL,
  `tag_id` int(11) NOT NULL,
  PRIMARY KEY (`article_id`,`tag_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article_tag_ref
-- ----------------------------
INSERT INTO `article_tag_ref` VALUES ('35', '6');
INSERT INTO `article_tag_ref` VALUES ('36', '6');
INSERT INTO `article_tag_ref` VALUES ('37', '1');
INSERT INTO `article_tag_ref` VALUES ('37', '2');
INSERT INTO `article_tag_ref` VALUES ('38', '2');
INSERT INTO `article_tag_ref` VALUES ('39', '1');
INSERT INTO `article_tag_ref` VALUES ('41', '1');
INSERT INTO `article_tag_ref` VALUES ('41', '3');
INSERT INTO `article_tag_ref` VALUES ('42', '1');
INSERT INTO `article_tag_ref` VALUES ('42', '2');
INSERT INTO `article_tag_ref` VALUES ('43', '4');
INSERT INTO `article_tag_ref` VALUES ('44', '1');
INSERT INTO `article_tag_ref` VALUES ('45', '7');
INSERT INTO `article_tag_ref` VALUES ('46', '7');
INSERT INTO `article_tag_ref` VALUES ('47', '1');
INSERT INTO `article_tag_ref` VALUES ('48', '1');
INSERT INTO `article_tag_ref` VALUES ('49', '8');
INSERT INTO `article_tag_ref` VALUES ('50', '1');
INSERT INTO `article_tag_ref` VALUES ('51', '2');
INSERT INTO `article_tag_ref` VALUES ('51', '3');
INSERT INTO `article_tag_ref` VALUES ('52', '11');
INSERT INTO `article_tag_ref` VALUES ('53', '7');
INSERT INTO `article_tag_ref` VALUES ('54', '1');
INSERT INTO `article_tag_ref` VALUES ('55', '1');
INSERT INTO `article_tag_ref` VALUES ('56', '7');

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `category_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `category_pid` int(11) DEFAULT NULL,
  `category_name` varchar(50) DEFAULT NULL,
  `category_description` varchar(255) DEFAULT NULL,
  `category_order` int(11) unsigned DEFAULT '1',
  `category_icon` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`category_id`),
  UNIQUE KEY `category_name` (`category_name`)
) ENGINE=InnoDB AUTO_INCREMENT=100000008 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES ('1', '0', 'Java', 'Java语言', '1', 'fa fa-coffee');
INSERT INTO `category` VALUES ('2', '1', 'Java基础', '', '1', '');
INSERT INTO `category` VALUES ('4', '1', '多线程并发编程', '', '1', '');
INSERT INTO `category` VALUES ('5', '1', 'Sockets和IO', '', '1', '');
INSERT INTO `category` VALUES ('6', '1', '设计模式和反射', '', '1', '');
INSERT INTO `category` VALUES ('7', '1', 'JVM', '', '1', '');
INSERT INTO `category` VALUES ('8', '1', 'JavaWeb', '', '1', '');
INSERT INTO `category` VALUES ('9', '1', 'Java框架', '', '1', '');
INSERT INTO `category` VALUES ('10', '0', '计算机科学', '', '1', 'fa fa-cubes');
INSERT INTO `category` VALUES ('11', '10', '数据结构和算法', '', '1', '');
INSERT INTO `category` VALUES ('12', '10', '操作系统', '', '1', '');
INSERT INTO `category` VALUES ('13', '10', '数据库', '', '1', '');
INSERT INTO `category` VALUES ('15', '0', '其他技术', '', '1', 'fa-snowflake-o fa');
INSERT INTO `category` VALUES ('16', '15', '消息服务', '', '1', '');
INSERT INTO `category` VALUES ('17', '15', '缓存服务', '', '1', '');
INSERT INTO `category` VALUES ('100000007', '0', '生活杂谈', '', '1', '');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `comment_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `comment_pid` int(11) unsigned DEFAULT '0',
  `comment_pname` varchar(255) DEFAULT NULL,
  `comment_article_id` int(11) unsigned DEFAULT NULL,
  `comment_author_name` varchar(50) DEFAULT NULL,
  `comment_author_email` varchar(50) DEFAULT NULL,
  `comment_author_url` varchar(50) DEFAULT NULL,
  `comment_author_avatar` varchar(100) DEFAULT NULL,
  `comment_content` varchar(1000) DEFAULT NULL,
  `comment_agent` varchar(200) DEFAULT NULL,
  `comment_ip` varchar(50) DEFAULT NULL,
  `comment_create_time` datetime DEFAULT NULL,
  `comment_role` int(1) DEFAULT NULL,
  PRIMARY KEY (`comment_id`)
) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES ('26', '0', '', '36', '张三', '359232556@qq.com', '', 'http://cn.gravatar.com/avatar/44ed687cbd0c546768763935ce7ab1db?s=128&d=identicon&r=PG', '啊，测试评论', null, '124.64.16.37', '2019-06-06 17:10:20', '0');
INSERT INTO `comment` VALUES ('27', '26', '张三', '36', '杨大力', '359232556@qq.com', '', null, '', null, '211.94.117.101', '2019-06-12 15:24:33', '1');
INSERT INTO `comment` VALUES ('28', '0', '', '41', '杨大力', '359232556@qq.com', '', 'http://cn.gravatar.com/avatar/44ed687cbd0c546768763935ce7ab1db?s=128&d=identicon&r=PG', '    啊呀，今天又被别人问到了对数据结构和算法了解多少。当时脑子就一片空白，数据结构嘛，是指逻辑上的对数据的存储以及处理方式。当时真的是一个字也想不起来了。\r\n    什么是逻辑意义上呢？数据结构的抽象表达非常的丰富，而存储结构却相对单一。例如二叉树，在磁盘上存储真的是树状的么？并非如此。树的存储结构可能是基于物理上的顺序存储方式。\r\n    什么是数据组织方式？逻辑意义上的组织方式很多，例如树，队列（先进先出），哈希（根据哈希值去定位）\r\n    什么是数据处理方式？在既定的数据结构上，以某种特定的算法实现数据的增删改查。这里又引出算法的时间复杂度及空间复杂度。', null, '124.64.19.254', '2019-06-17 20:09:44', '0');
INSERT INTO `comment` VALUES ('29', '0', '', '41', '杨大力', '359232556@qq.com', '', 'http://cn.gravatar.com/avatar/44ed687cbd0c546768763935ce7ab1db?s=128&d=identicon&r=PG', '    关于数据结构的分类，分为四类：1.线性结构（0至1个直接前继和后继）。2.树结构（0至1个直接前继和0至n个直接后继）。3.图结构。4.哈希结构***\r\n    引申出来的算法的时间复杂度和空间复杂度，在现阶段存储设备越来越便宜的如今，时间复杂度成为一个算法的重要考量点。***\r\n    算法时间复杂度是一种衡量计算性能的指标，反映了程序执行时间随输入规模增长而增长的量级，能够很大程度上反应出算法的优劣。而这个量级通常用一个大写的O和一个函数描述，例如O(n³)表示执行时间随输入规模呈现三次方倍的增长（例如：三层for循环嵌套，性能贼差）。常见的冒泡算法，由于其是两层for循环嵌套，最差时间复杂度为O(n²)，平均复杂度与最差复杂度相同，最优时间复杂度即为以排列好的集合，复杂度为O(n)。***\r\n    现实生活中，算法的时间复杂度还是比较重要的，时间复杂度低的程序随着数据量的急剧上升并不会影响到程序的性能，这就能称之为一个合格的算法。***', null, '124.64.19.254', '2019-06-17 20:18:47', '0');
INSERT INTO `comment` VALUES ('30', '0', '', '44', '杨大力', '359232556@qq.com', '', 'http://cn.gravatar.com/avatar/44ed687cbd0c546768763935ce7ab1db?s=128&d=identicon&r=PG', '使用集合，定义初始化长度成为了一个重要的性能优化的方面！！！', null, '124.64.19.254', '2019-06-17 21:16:00', '0');
INSERT INTO `comment` VALUES ('31', '0', '', '43', '落侑', '438965977@qq.com', '', 'http://cn.gravatar.com/avatar/6d3cfdcfddf89be715e40921a64b526b?s=128&d=identicon&r=PG', '过来学习学习', null, '124.89.116.102', '2019-06-19 18:01:50', '0');
INSERT INTO `comment` VALUES ('32', '0', '', '51', '杨大力', '359232556@qq.com', 'http://yangdali.cn', 'http://cn.gravatar.com/avatar/44ed687cbd0c546768763935ce7ab1db?s=128&d=identicon&r=PG', '当字符串超过10000，替换变量超过一百个时，考虑到效率问题，采用AC算法进行替换，效率将得到大大提升。', null, '124.64.17.17', '2019-07-10 16:32:53', '0');
INSERT INTO `comment` VALUES ('33', '0', '', '51', '杨大力', '359232556@qq.com', 'http://yangdali.cn', 'http://cn.gravatar.com/avatar/44ed687cbd0c546768763935ce7ab1db?s=128&d=identicon&r=PG', '有时间将会在本文章下继续补充AC算法的具体实现过程（踩在别的大神的肩膀上）。不过容我先看懂再说。哈哈', null, '124.64.17.17', '2019-07-10 16:34:14', '0');

-- ----------------------------
-- Table structure for link
-- ----------------------------
DROP TABLE IF EXISTS `link`;
CREATE TABLE `link` (
  `link_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `link_url` varchar(255) DEFAULT NULL,
  `link_name` varchar(255) DEFAULT NULL,
  `link_image` varchar(255) DEFAULT NULL,
  `link_description` varchar(255) DEFAULT NULL,
  `link_owner_nickname` varchar(40) DEFAULT NULL,
  `link_owner_contact` varchar(255) DEFAULT NULL,
  `link_update_time` datetime DEFAULT NULL,
  `link_create_time` datetime DEFAULT NULL,
  `link_order` int(2) unsigned DEFAULT '1',
  `link_status` int(1) unsigned DEFAULT '1',
  PRIMARY KEY (`link_id`),
  UNIQUE KEY `link_name` (`link_name`)
) ENGINE=MyISAM AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of link
-- ----------------------------

-- ----------------------------
-- Table structure for menu
-- ----------------------------
DROP TABLE IF EXISTS `menu`;
CREATE TABLE `menu` (
  `menu_id` int(11) NOT NULL AUTO_INCREMENT,
  `menu_name` varchar(255) DEFAULT NULL,
  `menu_url` varchar(255) DEFAULT NULL,
  `menu_level` int(11) DEFAULT NULL,
  `menu_icon` varchar(255) DEFAULT NULL,
  `menu_order` int(11) DEFAULT NULL,
  PRIMARY KEY (`menu_id`),
  UNIQUE KEY `menu_name` (`menu_name`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of menu
-- ----------------------------
INSERT INTO `menu` VALUES ('1', '留言板', '/message', '2', 'fa fa-comment', '1');
INSERT INTO `menu` VALUES ('4', '文章归档', '/articleFile', '1', 'fa-list-alt fa', '2');

-- ----------------------------
-- Table structure for NewTable
-- ----------------------------
DROP TABLE IF EXISTS `NewTable`;
CREATE TABLE `NewTable` (
  `id` varchar(255) NOT NULL,
  `name` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of NewTable
-- ----------------------------

-- ----------------------------
-- Table structure for notice
-- ----------------------------
DROP TABLE IF EXISTS `notice`;
CREATE TABLE `notice` (
  `notice_id` int(11) NOT NULL AUTO_INCREMENT,
  `notice_title` varchar(255) DEFAULT NULL,
  `notice_content` varchar(10000) DEFAULT NULL,
  `notice_create_time` datetime DEFAULT NULL,
  `notice_update_time` datetime DEFAULT NULL,
  `notice_status` int(1) unsigned DEFAULT '1',
  `notice_order` int(2) DEFAULT NULL,
  PRIMARY KEY (`notice_id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of notice
-- ----------------------------
INSERT INTO `notice` VALUES ('4', '开站啦！！！', '开始更新！以后可能要常常写博客了。', '2019-05-23 13:08:40', '2019-05-23 13:08:40', '1', '1');
INSERT INTO `notice` VALUES ('5', '文章欠缺，会在评论处进行补充！', '平时写的文章肯定不够全面和完整，可能还会存在错误。因此在以后发现时，会在评论中补充自己的看法，也欢迎大家踊跃评论!', '2019-06-19 20:59:15', '2019-06-19 20:59:15', '1', '1');

-- ----------------------------
-- Table structure for options
-- ----------------------------
DROP TABLE IF EXISTS `options`;
CREATE TABLE `options` (
  `option_id` int(11) NOT NULL,
  `option_site_title` varchar(255) DEFAULT NULL,
  `option_site_descrption` varchar(255) DEFAULT NULL,
  `option_meta_descrption` varchar(255) DEFAULT NULL,
  `option_meta_keyword` varchar(255) DEFAULT NULL,
  `option_aboutsite_avatar` varchar(255) DEFAULT NULL,
  `option_aboutsite_title` varchar(255) DEFAULT NULL,
  `option_aboutsite_content` varchar(255) DEFAULT NULL,
  `option_aboutsite_wechat` varchar(255) DEFAULT NULL,
  `option_aboutsite_qq` varchar(255) DEFAULT NULL,
  `option_aboutsite_github` varchar(255) DEFAULT NULL,
  `option_aboutsite_weibo` varchar(255) DEFAULT NULL,
  `option_tongji` varchar(255) DEFAULT NULL,
  `option_status` int(1) DEFAULT '1',
  PRIMARY KEY (`option_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of options
-- ----------------------------
INSERT INTO `options` VALUES ('1', '无道博客', '莫问收获，但问耕耘。', '风吟博客,一个简洁的Java博客,麻辣小龙虾程序学习的一个新起点。', 'Java博客', '/uploads/2018/11/avatar(3).jpg', '博客初心', '程序人生，永不止步', '/uploads/2017/10/20171006224906122.jpg', '847064370', 'saysky', '5936412667', null, '1');

-- ----------------------------
-- Table structure for page
-- ----------------------------
DROP TABLE IF EXISTS `page`;
CREATE TABLE `page` (
  `page_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `page_key` varchar(50) DEFAULT NULL,
  `page_title` varchar(50) DEFAULT NULL,
  `page_content` mediumtext,
  `page_create_time` datetime DEFAULT NULL,
  `page_update_time` datetime DEFAULT NULL,
  `page_view_count` int(10) unsigned DEFAULT '0',
  `page_comment_count` int(5) unsigned DEFAULT '0',
  `page_status` int(1) unsigned DEFAULT '1',
  PRIMARY KEY (`page_id`),
  UNIQUE KEY `page_key` (`page_key`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of page
-- ----------------------------
INSERT INTO `page` VALUES ('1', 'map', '站点地图', null, null, null, '0', '0', '2');
INSERT INTO `page` VALUES ('2', 'articleFile', '文章归档', null, null, null, '0', '0', '2');
INSERT INTO `page` VALUES ('3', 'message', '留言板', null, null, null, '0', '0', '2');
INSERT INTO `page` VALUES ('4', 'applyLink', '申请友链', null, null, null, '0', '0', '2');

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `tag_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(50) DEFAULT NULL,
  `tag_description` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`tag_id`),
  UNIQUE KEY `tag_name` (`tag_name`)
) ENGINE=InnoDB AUTO_INCREMENT=39 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES ('1', 'Java', 'Java');
INSERT INTO `tag` VALUES ('2', '算法', '');
INSERT INTO `tag` VALUES ('3', '数据结构', '');
INSERT INTO `tag` VALUES ('4', '计算机网络', '');
INSERT INTO `tag` VALUES ('5', 'MySQL', '');
INSERT INTO `tag` VALUES ('6', 'SpringMVC', '');
INSERT INTO `tag` VALUES ('7', 'JVM', '');
INSERT INTO `tag` VALUES ('8', '设计模式', '');
INSERT INTO `tag` VALUES ('9', '网络编程', '');
INSERT INTO `tag` VALUES ('10', 'JSP', '');
INSERT INTO `tag` VALUES ('11', 'JavaWeb', '');

-- ----------------------------
-- Table structure for test_a
-- ----------------------------
DROP TABLE IF EXISTS `test_a`;
CREATE TABLE `test_a` (
  `id` varchar(255) NOT NULL,
  `name` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of test_a
-- ----------------------------

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `user_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `user_name` varchar(255) NOT NULL DEFAULT '',
  `user_pass` varchar(255) NOT NULL DEFAULT '',
  `user_nickname` varchar(255) NOT NULL DEFAULT '',
  `user_email` varchar(100) DEFAULT '',
  `user_url` varchar(100) DEFAULT '',
  `user_avatar` varchar(255) DEFAULT NULL,
  `user_last_login_ip` varchar(255) DEFAULT NULL,
  `user_register_time` datetime DEFAULT NULL,
  `user_last_login_time` datetime DEFAULT NULL,
  `user_status` int(1) unsigned DEFAULT '1',
  PRIMARY KEY (`user_id`),
  UNIQUE KEY `user_name` (`user_name`),
  UNIQUE KEY `user_email` (`user_email`)
) ENGINE=MyISAM AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('4', 'shenjiawen', '950928', '嘉小文', '412887151@qq.com', '', '/uploads/2019/6/jiaxiaowen.jpg', '124.64.19.254', '2019-06-17 15:42:10', '2019-06-17 16:35:13', '1');
INSERT INTO `user` VALUES ('5', 'wangsong', '123456', '王松', '1395645243@qq.com', '', '/uploads/2019/7/20190716105850.jpg', '117.136.45.115', '2019-07-16 11:00:32', '2019-07-16 11:01:24', '1');
INSERT INTO `user` VALUES ('3', 'yangdali', 'yangli69841986', '杨大力', '359232556@qq.com', '', '/uploads/2019/5/20190523130927.jpg', '106.121.169.1', '2019-05-23 13:53:10', '2019-09-04 06:47:51', '1');
